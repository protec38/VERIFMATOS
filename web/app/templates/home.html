{% extends "base.html" %}
{% set title = "Tableau de bord" %}
{% block content %}

<div class="grid cols-2">
  <div class="card">
    <div class="title">CrÃ©er un Ã©vÃ©nement</div>
    <div class="subtitle">SÃ©lectionne les stocks Â« parents Â» Ã  vÃ©rifier (au moins un)</div>

    <form id="event-form" class="row wrap" style="margin-top:8px" onsubmit="return false;">
      <input type="text" name="name" id="ev-name" placeholder="Nom de l'Ã©vÃ©nement" required>
      <input type="date" name="date" id="ev-date" placeholder="Date (optionnel)">
    </form>

    <div class="alert" style="margin-top:10px">
      <div class="row wrap">
        {% if roots and roots|length %}
          {% for r in roots %}
            <label class="btn ghost" style="cursor:pointer;">
              <input type="checkbox" class="root-cb" value="{{ r.id }}" style="margin-right:6px"
                     data-name="{{ r.name }}"
                     data-unique="{{ 1 if r.unique_item else 0 }}"
                     data-max="{{ r.unique_quantity if r.unique_quantity is not none else '' }}">
              {{ r.name }}
            </label>
          {% endfor %}
        {% else %}
          <span class="muted">Aucun parent racine disponible. CrÃ©e dâ€™abord un stock parent dans ðŸ§° Stock.</span>
        {% endif %}
      </div>
      <div class="row wrap" style="margin-top:12px;gap:8px;align-items:center">
        <label for="template-select" class="muted">Template :</label>
        <select id="template-select" style="min-width:220px">
          <option value="">SÃ©lectionner un templateâ€¦</option>
          {% for tpl in templates %}
            <option value="{{ tpl.id }}">{{ tpl.name }}</option>
          {% endfor %}
        </select>
        <button class="btn" id="btn-save-template" type="button">ðŸ’¾ Enregistrer comme template</button>
      </div>
      <div class="row wrap" style="margin-top:8px;gap:8px;align-items:center">
        <label for="lot-select" class="muted">Lot :</label>
        <select id="lot-select" style="min-width:220px">
          <option value="">Ajouter un lotâ€¦</option>
          {% for lot in lots %}
            <option value="{{ lot.id }}">{{ lot.name }}</option>
          {% endfor %}
        </select>
        <button class="btn" id="btn-save-lot" type="button">ðŸ’¾ Enregistrer comme lot</button>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="btn-create" class="btn primary">CrÃ©er l'Ã©vÃ©nement</button>
    </div>
  </div>

  <div class="card">
    <div class="title">Derniers Ã©vÃ©nements</div>
    <table class="table" style="margin-top:8px">
      <thead>
        <tr>
          <th>Nom</th>
          <th>Statut</th>
          <th>Date</th>
          <th style="width:270px">Actions</th>
        </tr>
      </thead>
      <tbody id="events-body">
        {% for ev in events %}
        <tr data-id="{{ ev.id }}">
          <td><a href="{{ url_for('pages.event_page', event_id=ev.id) }}">{{ ev.name }}</a></td>
          <td>
            <span class="badge">{{ ev.status }}</span>
          </td>
          <td>{{ ev.date or "â€”" }}</td>
          <td class="row">
            <a class="btn" href="{{ url_for('pages.event_page', event_id=ev.id) }}">Ouvrir</a>
            <a class="btn" target="_blank" href="/reports/event/{{ ev.id }}/pdf">Export PDF</a>
            <button class="btn danger btn-del" data-id="{{ ev.id }}">Supprimer</button>
          </td>
        </tr>
        {% else %}
        <tr><td colspan="4" class="muted">Aucun Ã©vÃ©nement pour le moment.</td></tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
</div>

<script>
(function(){
  const byId = (id)=>document.getElementById(id);
  const rootSelections = new Map();
  const templateSpecs = {{ templates|tojson }};
  const lotSpecs = {{ lots|tojson }};
  const templateMap = new Map((templateSpecs||[]).map(t => [String(t.id), t]));
  const lotMap = new Map((lotSpecs||[]).map(t => [String(t.id), t]));

  function updateRootBadge(cb){
    const wrap = cb.closest('label');
    if(!wrap) return;
    let badge = wrap.querySelector('.root-qty');
    const id = parseInt(cb.value, 10);
    const qty = rootSelections.get(id);
    if(badge && (!cb.checked || qty==null)){
      badge.remove();
      badge = null;
    }
    if(cb.checked && qty != null){
      if(!badge){
        badge = document.createElement('span');
        badge.className = 'badge root-qty';
        badge.style.marginLeft = '6px';
        wrap.appendChild(badge);
      }
      badge.textContent = `QtÃ©: ${qty}`;
    }
  }

  document.querySelectorAll('.root-cb').forEach(cb => {
    cb.addEventListener('change', () => {
      const id = parseInt(cb.value, 10);
      const isUnique = (cb.dataset.unique === '1');
      if(cb.checked){
        if(isUnique){
          const maxRaw = cb.dataset.max;
          const max = maxRaw ? parseInt(maxRaw, 10) : null;
          const current = rootSelections.get(id) ?? (max ?? 1);
          const label = cb.dataset.name || 'parent';
          let msg = `QuantitÃ© dÃ©sirÃ©e pour ${label}`;
          if(max != null){ msg += ` (max ${max})`; }
          let input = prompt(msg, String(current));
          if(input === null){
            cb.checked = false;
            return;
          }
          let qty = parseInt(input, 10);
          if(isNaN(qty) || qty < 0){
            alert('QuantitÃ© invalide');
            cb.checked = false;
            return;
          }
          if(max != null && qty > max){
            alert(`QuantitÃ© supÃ©rieure au maximum (${max}).`);
            cb.checked = false;
            return;
          }
          rootSelections.set(id, qty);
        }else{
          rootSelections.delete(id);
        }
      }else{
        rootSelections.delete(id);
      }
      updateRootBadge(cb);
    });
  });

  function clearSelection(){
    document.querySelectorAll('.root-cb').forEach(cb => {
      cb.checked = false;
      const id = parseInt(cb.value, 10);
      rootSelections.delete(id);
      updateRootBadge(cb);
    });
  }

  function applyNodes(nodes, {reset=false}={}){
    if(reset){
      clearSelection();
    }
    if(!Array.isArray(nodes)) return;
    nodes.forEach(spec => {
      if(!spec) return;
      const id = parseInt(spec.id ?? spec.node_id, 10);
      if(!id) return;
      const cb = document.querySelector(`.root-cb[value="${id}"]`);
      if(!cb) return;
      cb.checked = true;
      if(spec.quantity != null){
        rootSelections.set(id, spec.quantity);
      }else{
        rootSelections.delete(id);
      }
      updateRootBadge(cb);
    });
  }

  function buildSelectionPayload(){
    const payload = [];
    document.querySelectorAll('.root-cb:checked').forEach(cb => {
      const id = parseInt(cb.value, 10);
      if(!id) return;
      const entry = {id};
      if(rootSelections.has(id)){
        entry.quantity = rootSelections.get(id);
      }
      payload.push(entry);
    });
    return payload;
  }

  const tplSelect = byId('template-select');
  tplSelect?.addEventListener('change', () => {
    const choice = tplSelect.value;
    if(!choice) return;
    const tpl = templateMap.get(choice);
    if(tpl){
      applyNodes(tpl.nodes || [], {reset:true});
    }
    tplSelect.value = '';
  });

  const lotSelect = byId('lot-select');
  lotSelect?.addEventListener('change', () => {
    const choice = lotSelect.value;
    if(!choice) return;
    const lot = lotMap.get(choice);
    if(lot){
      applyNodes(lot.nodes || [], {reset:false});
    }
    lotSelect.value = '';
  });

  async function saveSelection(kind){
    const nodes = buildSelectionPayload();
    if(nodes.length === 0){
      alert('SÃ©lectionne au moins un parent.');
      return;
    }
    const label = kind === 'LOT' ? 'Nom du lot' : 'Nom du template';
    const nameRaw = prompt(label + ' ?');
    if(!nameRaw){
      return;
    }
    const name = nameRaw.trim();
    if(!name){
      return;
    }
    try{
      const res = await fetch('/events/templates', {
        method: 'POST',
        headers: {'Content-Type':'application/json','Accept':'application/json'},
        body: JSON.stringify({name, kind, nodes})
      });
      const text = await res.text();
      if(!res.ok){
        alert(text || 'Enregistrement impossible.');
        return;
      }
      let data;
      try{ data = JSON.parse(text); }catch{ data = null; }
      if(!data){ return; }
      if(kind === 'LOT'){
        lotSpecs.push(data);
        lotMap.set(String(data.id), data);
        const opt = document.createElement('option');
        opt.value = data.id;
        opt.textContent = data.name;
        lotSelect?.appendChild(opt);
      }else{
        templateSpecs.push(data);
        templateMap.set(String(data.id), data);
        const opt = document.createElement('option');
        opt.value = data.id;
        opt.textContent = data.name;
        tplSelect?.appendChild(opt);
      }
      alert('EnregistrÃ©.');
    }catch(err){
      alert('Erreur: ' + err);
    }
  }

  byId('btn-save-template')?.addEventListener('click', () => saveSelection('TEMPLATE'));
  byId('btn-save-lot')?.addEventListener('click', () => saveSelection('LOT'));

  // -------- CrÃ©ation --------
  let creating = false;
  byId('btn-create')?.addEventListener('click', async () => {
    if (creating) return;
    const name = byId('ev-name').value.trim();
    const date = byId('ev-date').value || null;
    const selectedCbs = Array.from(document.querySelectorAll('.root-cb:checked'));
    const rootsPayload = [];
    for(const cb of selectedCbs){
      const id = parseInt(cb.value, 10);
      const isUnique = (cb.dataset.unique === '1');
      if(isUnique){
        if(!rootSelections.has(id)){
          alert(`SÃ©lectionne une quantitÃ© pour ${cb.dataset.name || 'ce parent'}.`);
          return;
        }
        rootsPayload.push({id, quantity: rootSelections.get(id)});
      }else{
        rootsPayload.push({id});
      }
    }

    if(!name){ alert("Nom requis"); return; }
    if(rootsPayload.length === 0){ alert("SÃ©lectionne au moins un parent"); return; }

    creating = true;
    try {
      const res = await fetch('/events', {
        method: 'POST',
        headers: {'Content-Type':'application/json', 'Accept':'application/json'},
        body: JSON.stringify({ name, date, roots: rootsPayload })
      });

      const text = await res.text();
      if(!res.ok){
        alert(text);
        return;
      }
      // Normalement JSON {url}
      let data; try{ data = JSON.parse(text); }catch{ data = {}; }
      if(data.url){ location.href = data.url; }
      else { location.reload(); }
    } catch (e){
      alert("Erreur rÃ©seau: "+ e);
    } finally {
      creating = false;
    }
  });

  // -------- Suppression (POST fallback) --------
  function bindDeleteButtons(scope=document){
    scope.querySelectorAll('.btn-del').forEach(btn => {
      if (btn._bound) return; // Ã©vite double-binding
      btn._bound = true;
      btn.addEventListener('click', async () => {
        const id = btn.getAttribute('data-id');
        if(!confirm("Supprimer cet Ã©vÃ©nement ?")) return;
        try {
          const res = await fetch(`/events/${id}/delete`, {
            method: 'POST',
            headers: {'Accept':'application/json'}
          });
          if(!res.ok){
            const t = await res.text();
            alert(t);
            return;
          }
          // Retire la ligne sans recharger
          const tr = document.querySelector(`tr[data-id="${id}"]`);
          tr?.parentNode?.removeChild(tr);
        } catch(e){
          alert("Erreur rÃ©seau: "+e);
        }
      });
    });
  }
  bindDeleteButtons();

  // -------- Actualisation douce de la liste (si endpoint JSON dispo) --------
  // On tente /events/list puis /api/events (gracieux si absent).
  const bodyEl = byId('events-body');

  function badgeHTML(status){
    return `<span class="badge">${status}</span>`;
  }

  function rowHTML(ev){
    const date = ev.date || "â€”";
    return `
      <tr data-id="${ev.id}">
        <td><a href="/events/${ev.id}">${ev.name}</a></td>
        <td>${badgeHTML(ev.status)}</td>
        <td>${date}</td>
        <td class="row">
          <a class="btn" href="/events/${ev.id}">Ouvrir</a>
          <a class="btn" target="_blank" href="/reports/event/${ev.id}/pdf">Export PDF</a>
          <button class="btn danger btn-del" data-id="${ev.id}">Supprimer</button>
        </td>
      </tr>`;
  }

  function diffApply(list){
    // index existants
    const existing = new Map();
    bodyEl.querySelectorAll('tr[data-id]').forEach(tr=>{
      existing.set(parseInt(tr.getAttribute('data-id'),10), tr);
    });

    // ajoute/maj
    const frag = document.createDocumentFragment();
    const order = [];
    list.forEach(ev=>{
      order.push(ev.id);
      const tr = existing.get(ev.id);
      if(!tr){
        const tmp = document.createElement('tbody');
        tmp.innerHTML = rowHTML(ev);
        const newTr = tmp.firstElementChild;
        frag.appendChild(newTr);
        bindDeleteButtons(newTr);
      }else{
        // mise Ã  jour lÃ©gÃ¨re des champs (sans remplacer lâ€™Ã©lÃ©ment pour Ã©viter flicker)
        const tds = tr.querySelectorAll('td');
        // nom (td0)
        const a = tds[0].querySelector('a');
        if (a && (a.textContent !== ev.name || a.getAttribute('href') !== `/events/${ev.id}`)) {
          a.textContent = ev.name;
          a.setAttribute('href', `/events/${ev.id}`);
        }
        // statut (td1)
        const statusCell = tds[1];
        if (statusCell && statusCell.innerHTML.trim() !== badgeHTML(ev.status)) {
          statusCell.innerHTML = badgeHTML(ev.status);
        }
        // date (td2)
        const date = ev.date || "â€”";
        if (tds[2] && tds[2].textContent.trim() !== date) {
          tds[2].textContent = date;
        }
        // actions (td3) â€” liens inchangÃ©s sauf PDF
        const pdf = tr.querySelector(`a[href="/reports/event/${ev.id}/pdf"]`);
        if (!pdf) {
          const actions = tds[3];
          const btnPDF = document.createElement('a');
          btnPDF.className = 'btn';
          btnPDF.target = '_blank';
          btnPDF.href = `/reports/event/${ev.id}/pdf`;
          btnPDF.textContent = 'Export PDF';
          actions.insertBefore(btnPDF, actions.querySelector('.btn-del'));
        }
      }
    });

    // insÃ¨re les nouveaux Ã  la fin
    if (frag.childNodes.length) bodyEl.appendChild(frag);

    // supprime les lignes qui nâ€™existent plus
    existing.forEach((tr, id)=>{
      if(!list.find(e=>e.id===id)){
        tr.parentNode.removeChild(tr);
      }
    });
  }

  async function fetchEventsOnce(){
    try{
      let res = await fetch('/events/list', {headers:{'Accept':'application/json'}});
      if(!res.ok){
        // tentative alternative
        res = await fetch('/api/events', {headers:{'Accept':'application/json'}});
      }
      if(!res.ok) return; // silencieux si pas dâ€™endpoint
      const data = await res.json(); // attendu: [{id,name,status,date}, ...]
      if(Array.isArray(data)) diffApply(data);
    }catch(_){}
  }

  // polling doux toutes les 5s (si endpoint prÃ©sent)
  setInterval(fetchEventsOnce, 5000);
})();
</script>

{% endblock %}
