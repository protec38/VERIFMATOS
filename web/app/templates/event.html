{% extends "base.html" %}
{% set title = "Événement" %}
{% block content %}

<style>
  .page-event{display:flex;flex-direction:column;gap:16px}
  .event-layout{display:grid;grid-template-columns:minmax(0,2.1fr) minmax(0,1fr);gap:16px;align-items:stretch}
  @media(max-width:1100px){.event-layout{grid-template-columns:1fr}}
  .card{position:relative;overflow:hidden}
  .state-ok{
    border-color:rgba(66,207,173,.45) !important;
    background:linear-gradient(135deg,rgba(20,60,52,.85),rgba(9,30,24,.92));
    box-shadow:0 0 0 1px rgba(66,207,173,.35) inset,0 16px 28px rgba(18,184,134,.18);
  }
  .state-bad{
    border-color:rgba(255,107,107,.4) !important;
    background:linear-gradient(135deg,rgba(66,20,28,.85),rgba(30,8,12,.9));
    box-shadow:0 0 0 1px rgba(255,107,107,.28) inset,0 16px 28px rgba(255,107,107,.15);
  }
  .state-wait{
    border-color:rgba(79,126,255,.35) !important;
    background:linear-gradient(135deg,rgba(22,40,70,.82),rgba(12,22,36,.9));
    box-shadow:0 0 0 1px rgba(79,126,255,.25) inset;
  }
  .overview-card{padding:24px;background:radial-gradient(circle at top left,rgba(79,126,255,.28),transparent 55%),linear-gradient(135deg,rgba(18,35,64,.95),rgba(12,21,36,.92));border:1px solid rgba(126,162,255,.25);box-shadow:0 20px 45px rgba(12,25,46,.35)}
  .overview-card .title{font-size:26px;font-weight:800;color:#eef4ff}
  .overview-meta{display:flex;flex-direction:column;gap:6px}
  .overview-meta .muted{color:rgba(232,243,255,.75);font-size:14px}
  .event-badge{position:absolute;top:20px;right:24px;padding:6px 12px;border-radius:999px;background:rgba(11,19,33,.65);border:1px solid rgba(158,201,255,.35);font-size:12px;font-weight:700;letter-spacing:.02em;text-transform:uppercase}
  .event-badge[data-status="OPEN"]{color:#bff3e7;border-color:rgba(66,207,173,.45);background:rgba(14,42,36,.65)}
  .event-badge[data-status="CLOSED"]{color:#ffd5dc;border-color:rgba(255,107,107,.35);background:rgba(42,14,20,.65)}
  .overview-actions{display:flex;flex-wrap:wrap;gap:10px;margin-top:18px}
  .overview-actions .btn{background:rgba(11,19,33,.65);border-color:rgba(158,201,255,.25)}
  .overview-actions .btn.primary{background:linear-gradient(135deg,#4276ff,#6d93ff);border-color:transparent;color:#fff;box-shadow:0 12px 30px rgba(66,118,255,.25)}
  .overview-actions .btn.primary:hover{filter:brightness(1.05)}
  .stat-card{padding:24px;background:linear-gradient(160deg,rgba(16,30,49,.95),rgba(12,22,36,.92));border:1px solid rgba(89,129,207,.3);box-shadow:0 14px 32px rgba(11,20,36,.32)}
  .stat-title{font-weight:800;font-size:18px;color:#e5eeff}
  .stat-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:10px;margin-top:14px}
  .chip{padding:10px 12px;border-radius:12px;font-weight:800;font-size:13px;border:1px solid rgba(158,201,255,.2);background:rgba(15,26,43,.85);display:flex;flex-direction:column;gap:4px;min-height:70px;justify-content:center}
  .chip-label{font-size:12px;font-weight:500;letter-spacing:.01em;text-transform:uppercase;color:rgba(193,211,238,.72)}
  .chip-value{font-size:18px}
  .chip.ok{border-color:rgba(66,207,173,.45);background:rgba(14,42,36,.75);color:#bff3e7}
  .chip.bad{border-color:rgba(255,107,107,.35);background:rgba(42,14,20,.75);color:#ffd5dc}
  .chip.wait{border-color:rgba(79,126,255,.35);background:rgba(16,28,46,.78);color:#b7c7dc}
  .status-dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:8px;vertical-align:middle}
  .dot-ok{background:var(--success)}
  .dot-bad{background:var(--danger)}
  .dot-wait{background:#37527a}
  .progress{height:8px;border-radius:999px;background:rgba(255,255,255,.06);overflow:hidden;margin-top:14px}
  .progress > div{height:100%;border-radius:999px;background:linear-gradient(135deg,#4276ff,#51bdf2);transition:width .4s ease}
  .progress-caption{margin-top:8px;color:rgba(193,211,238,.75);font-size:13px}
  .section-card{padding:22px;background:linear-gradient(160deg,rgba(12,20,34,.92),rgba(15,28,46,.92));border:1px solid rgba(158,201,255,.18);box-shadow:0 12px 32px rgba(8,17,30,.22)}
  .section-heading{display:flex;flex-wrap:wrap;align-items:flex-start;justify-content:space-between;gap:10px}
  .section-heading .title{font-size:20px;font-weight:800;color:#e5eeff}
  .section-heading .muted{font-size:13px;color:rgba(193,211,238,.7)}
  .parents-card .title{display:flex;align-items:center;gap:10px}
  .parents-bar{display:flex;gap:8px;overflow:auto;padding:10px 2px 4px 2px}
  .parent-pill{display:inline-flex;align-items:center;gap:10px;padding:10px 14px;border-radius:999px;border:1px solid rgba(158,201,255,.2);cursor:pointer;user-select:none;white-space:nowrap;transition:transform .12s ease, box-shadow .12s ease, border-color .12s ease;background:rgba(11,19,33,.75);color:#e2ecff;font-weight:600}
  .parent-pill:hover{transform:translateY(-1px);box-shadow:0 10px 22px rgba(10,20,34,.28)}
  .pill-ok{border-color:rgba(66,207,173,.45);background:rgba(14,42,36,.78);color:#bff3e7}
  .pill-bad{border-color:rgba(255,107,107,.35);background:rgba(42,14,20,.78);color:#ffd5dc}
  .pill-wait{border-color:rgba(79,126,255,.35);background:rgba(16,28,46,.78);color:#b7c7dc}
  .focus-ring{outline:2px solid var(--pc-orange);outline-offset:3px;transition:outline-color .6s ease}
  .manage-card .parent-pill{cursor:default}
  .manage-card .parent-pill .btn{margin-left:6px}
  .btn.sm{padding:6px 10px;font-size:12px;border-radius:8px}
  .btn.sm:disabled{opacity:.6;cursor:not-allowed}
  #event-roots-status{margin-top:8px;font-size:13px;display:none;color:var(--muted)}
  #event-roots-status.success{color:#bff3e7}
  #event-roots-status.error{color:#ffd5dc}
  #event-roots-hint{margin-top:6px;font-size:13px;color:var(--muted)}
  .schedule-list{display:flex;flex-direction:column;gap:12px;margin-top:16px}
  .schedule-item{display:flex;flex-wrap:wrap;gap:14px;align-items:flex-start;justify-content:space-between;padding:16px;border-radius:14px;border:1px solid rgba(158,201,255,.25);background:rgba(13,22,36,.82);box-shadow:0 14px 28px rgba(7,12,23,.25)}
  .schedule-item .time{font-weight:800;color:#dde8fb;font-size:15px}
  .schedule-item .nodes{color:rgba(193,211,238,.75);margin-top:4px;font-size:13px;max-width:520px}
  .schedule-item .label{font-size:12px;text-transform:uppercase;letter-spacing:.04em;color:rgba(193,211,238,.6);margin-bottom:4px}
  .vehicle{font-size:12px;opacity:.9;padding:3px 8px;border-radius:8px;border:1px dashed rgba(158,201,255,.25);margin-left:8px}
  .vehicle.on{background:#0e2a24;color:#bff3e7;border-color:#1d6e5d}
  .vehicle.off{background:#101c2e;color:#b7c7dc;border-color:#24344f}
  .reassort-note{font-size:12px;padding:3px 8px;border-radius:8px;border:1px dashed rgba(245,199,111,.45);margin-left:8px;background:#33240f;color:#f5c76f;display:inline-flex;align-items:center;gap:6px}
  .reassort-note.empty{display:none}
  .parent-pill .reassort-chip{margin-left:8px;font-size:11px;padding:4px 8px;border-radius:999px;background:#2e1a07;color:#f5c76f;border:1px solid rgba(245,199,111,.35)}
  .modal-back{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:90}
  .modal-card{background:#0f1a2a;padding:20px;border-radius:12px;min-width:280px;max-width:420px;box-shadow:0 18px 45px rgba(0,0,0,.45)}
  .modal-card .title{margin-bottom:10px}
  .modal-card label{font-size:13px;color:var(--muted);margin-top:6px;display:block}
  .modal-card input,.modal-card textarea{width:100%;margin-top:6px}
  .modal-card .modal-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:16px}
  .modal-card textarea{min-height:90px;resize:vertical}
  .header.toggle{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-radius:12px;cursor:pointer;background:rgba(14,24,38,.6);transition:background .2s ease,transform .1s ease}
  .header.toggle:hover{background:rgba(255,255,255,.05);transform:translateY(-1px)}
  .header .left{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  .header .group-name{font-weight:800}
  .chev{width:18px;display:inline-flex;align-items:center;justify-content:center;opacity:.85}
  .childs{padding:12px 14px 8px 34px}
  .childs.collapsed{display:none}
  .slot-chip{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;padding:12px 14px;border-radius:12px;border:1px dashed rgba(158,201,255,.3);background:rgba(14,24,38,.75)}
  .slot-chip .info{font-weight:700;color:#d8e6fb}
  .slot-chip .meta{color:var(--muted);font-size:12px}
  #event-slot-display .schedule-item{width:100%}
  #event-slots-status{margin-top:8px;font-size:13px;color:var(--muted);display:none}
  #event-slots-status.success{color:#bff3e7}
  #event-slots-status.error{color:#ffd5dc}
</style>

<div class="page-event">
  <div class="event-layout">
    <div class="card overview-card">
      <span class="event-badge" id="status-badge" data-status="{{ event_status|upper }}">Statut : {{ event_status }}</span>
      <div class="overview-meta">
        <div class="title">{{ event.name }}</div>
        <div class="muted">Date : {{ event.date or "—" }}</div>
      </div>
      <div class="overview-actions">
        <a class="btn" target="_blank" href="/reports/event/{{ event.id }}/pdf">Exporter PDF</a>
        <button class="btn primary" id="btn-share">Lien secouristes</button>
        <button class="btn" id="btn-close">{{ "Clôturer l'événement" if event_status == "OPEN" else "Réouvrir l'événement" }}</button>
      </div>
    </div>

    <div class="card stat-card">
      <div class="stat-title">Progression</div>
      <div class="stat-grid">
        <span class="chip ok" id="stat-ok">
          <span class="chip-label">OK</span>
          <span class="chip-value">0</span>
        </span>
        <span class="chip bad" id="stat-bad">
          <span class="chip-label">Non conformes</span>
          <span class="chip-value">0</span>
        </span>
        <span class="chip wait" id="stat-wait">
          <span class="chip-label">En attente</span>
          <span class="chip-value">0</span>
        </span>
      </div>
      <div class="progress"><div id="progress-bar" style="width:0%"></div></div>
      <div class="progress-caption" id="progress-text">0 / 0 vérifiés</div>
    </div>
  </div>

  <div class="card parents-card section-card">
    <div class="section-heading">
      <div class="title">Parents à vérifier</div>
      <div class="muted">Identifie rapidement les lots à contrôler.</div>
    </div>
    <div id="parents-bar" class="parents-bar"></div>
  </div>

  {% if can_manage %}
  <div class="card manage-card section-card" id="event-roots-card">
    <div class="section-heading">
      <div class="title">Gestion des objets</div>
      <div class="muted">Ajoute ou retire des objets pour cet événement.</div>
    </div>
    <div id="event-roots-list" class="row wrap" style="margin-top:12px;gap:8px;"></div>
    <div class="row wrap" style="margin-top:12px;gap:8px;">
      <select id="event-root-add-select" style="min-width:220px">
        <option value="">Ajouter un objet…</option>
      </select>
      <button class="btn primary sm manage-action" id="btn-add-root">Ajouter</button>
    </div>
    <div id="event-roots-hint"></div>
    <div id="event-roots-status" class="muted"></div>
  </div>
  {% endif %}

  <div class="card section-card">
    <div class="section-heading">
      <div class="title">Créneaux réservés</div>
      <div class="muted">Consulte les créneaux planifiés ou ouvre le <a href="/calendar">calendrier du matériel</a> pour la vision globale.</div>
    </div>
    <div class="schedule-list" id="event-slot-display">
      {% if material_slots %}
        {% for slot in material_slots %}
          <div class="schedule-item">
            <div>
              <div class="label">Plage horaire</div>
              <div class="time">{{ slot.start.strftime('%d/%m/%Y %H:%M') }} → {{ slot.end.strftime('%d/%m/%Y %H:%M') }}</div>
            </div>
            <div>
              <div class="label">Matériel</div>
              <div class="nodes">{{ slot.nodes|join(', ') }}</div>
            </div>
          </div>
        {% endfor %}
      {% else %}
        <div class="muted">Aucun créneau configuré pour le moment.</div>
      {% endif %}
    </div>
  </div>

  {% if can_manage %}
  <div class="card manage-card section-card" id="event-slots-card">
    <div class="section-heading">
      <div class="title">Modifier les créneaux</div>
      <div class="muted">Ajoute, retire ou ajuste les créneaux de réservation pour ce matériel.</div>
    </div>
    <div id="event-slots-edit-list" class="column" style="margin-top:12px;gap:8px;display:flex;"></div>
    <div class="row wrap" style="margin-top:12px;gap:8px;">
      <input type="datetime-local" id="event-slot-start" class="manage-action" style="min-width:200px">
      <input type="datetime-local" id="event-slot-end" class="manage-action" style="min-width:200px">
      <button class="btn primary sm manage-action" id="btn-add-slot">Ajouter</button>
    </div>
    <div class="muted" id="event-slots-hint" style="margin-top:6px;"></div>
    <div class="row wrap" style="margin-top:12px;gap:8px;">
      <button class="btn primary manage-action" id="btn-save-slots" disabled>Enregistrer</button>
      <button class="btn ghost manage-action" id="btn-reset-slots" disabled>Réinitialiser</button>
    </div>
    <div id="event-slots-status" class="muted"></div>
  </div>
  {% endif %}

  <div class="card section-card">
    <div class="section-heading">
      <div class="title">Matériel à vérifier</div>
      <div class="muted">Vert = tout OK • Rouge = au moins un non conforme • Bleu = en attente</div>
    </div>
    <div id="tree" class="tree" style="margin-top:10px;"></div>
  </div>
</div>

<script>
const EVENT_ID = {{ event.id }};
let TREE = {{ (tree or [])|tojson }};
const CURRENT_USER = "{{ (current_user.username if current_user is defined and current_user.is_authenticated else '')|e }}";
const SHOW_VERIFY = {{ 'true' if allow_verify else 'false' }};
let IS_OPEN = ("{{ event_status }}".toUpperCase() === "OPEN");

const ALLOW_CHARGE = {{ 'true' if can_manage else 'false' }};
const INITIAL_SLOT_DATA = {{ (material_slots_payload or [])|tojson }};
let SLOT_BASELINE = cloneSlots(INITIAL_SLOT_DATA);
let SLOT_STATE = cloneSlots(INITIAL_SLOT_DATA);
let SLOTS_DIRTY = false;
let SLOTS_SAVING = false;
const SLOT_FMT_FULL = new Intl.DateTimeFormat('fr-FR', {day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit'});

/* ========= State ========= */
const NODE_MAP = new Map();
const GROUP_EL = new Map();
const ITEM_EL  = new Map();
const ITEM_STATUS_TXT = new Map();
const ITEM_QTY_TXT = new Map();
const VEH_LABEL = new Map();
const CHARGE_BUTTON = new Map();
const REASSORT_LABEL = new Map();
const REASSORT_BUTTON = new Map();
const COLLAPSED = new Map();
const CAN_MANAGE = {{ 'true' if can_manage else 'false' }};
const EVENT_ROOTS = new Map();
const ROOT_CHOICES_MAP = new Map();
let ROOTS_STATUS_TIMER = null;
let ROOTS_SAVING = false;
let FULL_RELOAD_IN_PROGRESS = false;
let CHARGE_TARGET = null;
let REASSORT_TARGET = null;

/* ---------- Utils ---------- */
function indexTree(nodes){
  (nodes||[]).forEach(function rec(n){
    NODE_MAP.set(n.id, n);
    (n.children||[]).forEach(rec);
  });
}
function el(tag, attrs={}, ...children){
  const e = document.createElement(tag);
  for(const [k,v] of Object.entries(attrs||{})){
    if(k==="class") e.className = v;
    else if(k==="html") e.innerHTML = v;
    else if(k.startsWith("on") && typeof v==="function") e.addEventListener(k.slice(2), v);
    else e.setAttribute(k, v);
  }
  for(const c of children){ if(c!=null) e.append(c.nodeType?c:document.createTextNode(c)); }
  return e;
}
function parseDateValue(value){
  if(!value) return null;
  const d = new Date(value);
  if(Number.isNaN(d.getTime())) return null;
  return d;
}
function slotSort(a, b){
  const startA = parseDateValue(a.start);
  const startB = parseDateValue(b.start);
  if(startA && startB && startA.getTime() !== startB.getTime()){
    return startA.getTime() - startB.getTime();
  }
  const endA = parseDateValue(a.end);
  const endB = parseDateValue(b.end);
  if(endA && endB && endA.getTime() !== endB.getTime()){
    return endA.getTime() - endB.getTime();
  }
  const startCmp = String(a.start||"").localeCompare(String(b.start||""));
  if(startCmp !== 0) return startCmp;
  return String(a.end||"").localeCompare(String(b.end||""));
}
function normalizeSlotEntry(entry){
  if(!entry) return null;
  const startRaw = entry.start || entry.from || entry.begin || "";
  const endRaw = entry.end || entry.to || entry.finish || "";
  const start = String(startRaw || "").trim();
  const end = String(endRaw || "").trim();
  if(!start || !end) return null;
  let nodes = [];
  if(Array.isArray(entry.nodes)){
    nodes = entry.nodes.filter(Boolean).map(v => String(v));
    nodes.sort((a,b)=>a.localeCompare(b,'fr',{sensitivity:'base'}));
  }
  return {start, end, nodes};
}
function cloneSlots(list){
  const clone = [];
  (list||[]).forEach(entry => {
    const normalized = normalizeSlotEntry(entry);
    if(normalized){
      clone.push({...normalized});
    }
  });
  clone.sort(slotSort);
  return clone;
}
function currentRootNames(){
  const names = [];
  EVENT_ROOTS.forEach(spec => {
    if(!spec) return;
    names.push(spec.name || `Parent ${spec.id}`);
  });
  names.sort((a,b)=>a.localeCompare(b,'fr',{sensitivity:'base'}));
  return names;
}
function ensureSlotNodes(list){
  if(!Array.isArray(list) || list.length === 0) return false;
  const names = currentRootNames();
  let changed = false;
  list.forEach(slot => {
    if(!slot) return;
    const same = Array.isArray(slot.nodes)
      && slot.nodes.length === names.length
      && slot.nodes.every((value, index) => value === names[index]);
    if(!same){
      slot.nodes = names.slice();
      changed = true;
    }
  });
  return changed;
}
function slotNodesLabel(slot){
  if(slot && Array.isArray(slot.nodes) && slot.nodes.length){
    return slot.nodes.join(', ');
  }
  const names = currentRootNames();
  return names.length ? names.join(', ') : '—';
}
function formatSlotRange(slot){
  if(!slot) return '';
  const startDate = parseDateValue(slot.start);
  const endDate = parseDateValue(slot.end);
  if(startDate && endDate){
    return `${SLOT_FMT_FULL.format(startDate)} → ${SLOT_FMT_FULL.format(endDate)}`;
  }
  return `${slot.start} → ${slot.end}`;
}
const isUnique = n => !!(n && n.unique_item);
const isUniqueParent = n => !!(n && n.unique_parent);
const targetNodeId = n => (n && (n.target_node_id || n.id));
const domSafeId = id => String(id).replace(/[^a-zA-Z0-9_-]/g, "-");
function formatChargeInfo(vehicle, operator){
  const veh = (vehicle && vehicle.trim()) ? vehicle.trim() : "—";
  if(operator && operator.trim()){
    return `${veh} (par ${operator.trim()})`;
  }
  return veh;
}
const isItem = n => {
  if(!n) return false;
  if(isUniqueParent(n)) return false;
  const type = (n.type||"").toUpperCase();
  return type === "ITEM" || (!!n.unique_item && !isUniqueParent(n));
};
const isGroup = n => !isItem(n);
function normStatus(s){
  s = (s||"").toUpperCase();
  if(s==="OK") return "OK";
  if(s==="NOT_OK" || s==="NOK" || s==="KO" || s==="NOT-OK" || s==="NOTOK") return "NOT_OK";
  return "PENDING";
}

/* ---------- Statuts ---------- */
function groupAllOk(n){
  const items = flattenItems([n]);
  return items.length > 0 && items.every(i => normStatus(i.last_status) === "OK");
}
function groupHasBad(n){
  return flattenItems([n]).some(i => normStatus(i.last_status) === "NOT_OK");
}
function canChargeGroup(n){
  if(!ALLOW_CHARGE) return false;
  if(!IS_OPEN) return false;
  return groupAllOk(n);
}
function groupStatus(n){
  if(groupAllOk(n)) return "OK";
  if(groupHasBad(n)) return "BAD";
  return "WAIT";
}
function flattenItems(nodes){
  const out=[]; (nodes||[]).forEach(function rec(n){
    if(isItem(n) || isUniqueParent(n)) out.push(n);
    (n.children||[]).forEach(rec);
  });
  return out;
}

/* ---------- Gestion créneaux événement ---------- */
function setSlotsStatus(message, type="info"){
  if(!CAN_MANAGE) return;
  const elStatus = document.getElementById("event-slots-status");
  if(!elStatus) return;
  elStatus.classList.remove("success", "error");
  if(!message){
    elStatus.textContent = "";
    elStatus.style.display = "none";
    return;
  }
  if(type === "success") elStatus.classList.add("success");
  else if(type === "error") elStatus.classList.add("error");
  elStatus.textContent = message;
  elStatus.style.display = "block";
}

function updateSlotsHint(){
  if(!CAN_MANAGE) return;
  const hint = document.getElementById("event-slots-hint");
  if(!hint) return;
  if(SLOT_STATE.length === 0){
    hint.textContent = "Ajoute au moins un créneau (date et heures de départ / fin).";
  } else {
    hint.textContent = `${SLOT_STATE.length} créneau${SLOT_STATE.length>1?'x':''} configuré${SLOT_STATE.length>1?'s':''}.`;
  }
}

function updateSlotsButtons(){
  if(!CAN_MANAGE) return;
  const saveBtn = document.getElementById("btn-save-slots");
  if(saveBtn){
    saveBtn.disabled = SLOTS_SAVING || !SLOTS_DIRTY || SLOT_STATE.length === 0;
  }
  const resetBtn = document.getElementById("btn-reset-slots");
  if(resetBtn){
    resetBtn.disabled = SLOTS_SAVING || !SLOTS_DIRTY;
  }
}

function setSlotsControlsDisabled(flag){
  if(!CAN_MANAGE) return;
  document.querySelectorAll('#event-slots-card .manage-action').forEach(ctrl => {
    ctrl.disabled = flag;
  });
  updateSlotsButtons();
}

function renderSlotDisplay(){
  const holder = document.getElementById("event-slot-display");
  if(!holder) return;
  holder.innerHTML = "";
  if(SLOT_STATE.length === 0){
    holder.appendChild(el("div", {class:"muted"}, "Aucun créneau configuré pour le moment."));
    return;
  }
  SLOT_STATE.forEach(slot => {
    holder.appendChild(
      el("div", {class:"schedule-item"},
        el("div", {},
          el("div", {class:"time"}, formatSlotRange(slot)),
          el("div", {class:"nodes"}, `Matériel : ${slotNodesLabel(slot)}`)
        )
      )
    );
  });
}

function renderSlotEditor(){
  if(!CAN_MANAGE) return;
  const holder = document.getElementById("event-slots-edit-list");
  if(!holder) return;
  holder.innerHTML = "";
  if(SLOT_STATE.length === 0){
    holder.appendChild(el("div", {class:"muted"}, "Aucun créneau configuré."));
    updateSlotsHint();
    return;
  }
  SLOT_STATE.forEach((slot, index) => {
    const row = el("div", {class:"slot-chip"});
    const removeBtn = el("button", {
      class:"btn danger sm manage-action",
      onclick: () => {
        SLOT_STATE.splice(index, 1);
        markSlotsDirty(true);
        renderSlotEditor();
        renderSlotDisplay();
      }
    }, "Retirer");
    row.append(
      el("div", {class:"info"}, formatSlotRange(slot)),
      el("div", {class:"meta"}, `Créneau ${index + 1}`),
      removeBtn
    );
    holder.appendChild(row);
  });
  updateSlotsHint();
}

function markSlotsDirty(flag){
  if(!CAN_MANAGE) return;
  SLOTS_DIRTY = !!flag;
  if(SLOTS_DIRTY){
    setSlotsStatus("Modifications non enregistrées.", "info");
  } else {
    setSlotsStatus("", "info");
  }
  updateSlotsButtons();
}

function syncSlotsNodesFromRoots(){
  const changedCurrent = ensureSlotNodes(SLOT_STATE);
  const changedBaseline = ensureSlotNodes(SLOT_BASELINE);
  return changedCurrent || changedBaseline;
}

function addSlotFromInputs(){
  if(!CAN_MANAGE) return;
  const startInput = document.getElementById("event-slot-start");
  const endInput = document.getElementById("event-slot-end");
  const startVal = (startInput?.value || "").trim();
  const endVal = (endInput?.value || "").trim();
  if(!startVal || !endVal){
    alert("Renseigne les dates de début et de fin.");
    return;
  }
  const startDate = parseDateValue(startVal);
  const endDate = parseDateValue(endVal);
  if(!startDate || !endDate){
    alert("Format de date/heure invalide.");
    return;
  }
  if(endDate <= startDate){
    alert("La fin du créneau doit être après le début.");
    return;
  }
  if(SLOT_STATE.some(slot => slot.start === startVal && slot.end === endVal)){
    alert("Ce créneau est déjà présent.");
    return;
  }
  const overlaps = SLOT_STATE.some(slot => {
    const existingStart = parseDateValue(slot.start);
    const existingEnd = parseDateValue(slot.end);
    return existingStart && existingEnd && endDate > existingStart && startDate < existingEnd;
  });
  if(overlaps && !confirm("Ce créneau chevauche un autre créneau déjà ajouté. Continuer malgré tout ?")){
    return;
  }
  const names = currentRootNames();
  SLOT_STATE.push({start: startVal, end: endVal, nodes: names.slice()});
  SLOT_STATE.sort(slotSort);
  if(startInput) startInput.value = "";
  if(endInput) endInput.value = "";
  markSlotsDirty(true);
  renderSlotEditor();
  renderSlotDisplay();
}

async function saveSlots(){
  if(!CAN_MANAGE) return;
  if(SLOT_STATE.length === 0){
    alert("Ajoute au moins un créneau.");
    return;
  }
  SLOTS_SAVING = true;
  setSlotsControlsDisabled(true);
  setSlotsStatus("Enregistrement en cours…", "info");
  try{
    const res = await fetch(`/events/${EVENT_ID}/slots`, {
      method: "PUT",
      credentials: "include",
      headers: {"Content-Type": "application/json", "Accept": "application/json"},
      body: JSON.stringify({
        slots: SLOT_STATE.map(slot => ({start: slot.start, end: slot.end}))
      })
    });
    const text = await res.text();
    if(!res.ok){
      setSlotsStatus("", "info");
      alert(text || "Impossible d'enregistrer les créneaux.");
      return;
    }
    let data = {};
    try{ data = text ? JSON.parse(text) : {}; }catch(_){ data = {}; }
    const latest = cloneSlots((data && data.slots) || []);
    SLOT_BASELINE = cloneSlots(latest);
    SLOT_STATE = cloneSlots(latest);
    ensureSlotNodes(SLOT_BASELINE);
    ensureSlotNodes(SLOT_STATE);
    renderSlotDisplay();
    renderSlotEditor();
    markSlotsDirty(false);
    setSlotsStatus("Créneaux enregistrés.", "success");
  }catch(_){
    setSlotsStatus("", "info");
    alert("Erreur réseau");
  }finally{
    SLOTS_SAVING = false;
    setSlotsControlsDisabled(false);
  }
}

function resetSlots(){
  if(!CAN_MANAGE) return;
  SLOT_STATE = cloneSlots(SLOT_BASELINE);
  ensureSlotNodes(SLOT_STATE);
  renderSlotDisplay();
  renderSlotEditor();
  markSlotsDirty(false);
  setSlotsStatus("Modifications annulées.", "info");
}

function setupSlotsEditor(){
  if(!CAN_MANAGE) return;
  const addBtn = document.getElementById("btn-add-slot");
  if(addBtn) addBtn.addEventListener("click", addSlotFromInputs);
  const saveBtn = document.getElementById("btn-save-slots");
  if(saveBtn) saveBtn.addEventListener("click", saveSlots);
  const resetBtn = document.getElementById("btn-reset-slots");
  if(resetBtn) resetBtn.addEventListener("click", resetSlots);
  updateSlotsHint();
  updateSlotsButtons();
}

/* ---------- Gestion parents événement ---------- */
function setRootsStatus(message, type="info", autoHideMs){
  if(!CAN_MANAGE) return;
  const el = document.getElementById("event-roots-status");
  if(!el) return;
  if(ROOTS_STATUS_TIMER){
    clearTimeout(ROOTS_STATUS_TIMER);
    ROOTS_STATUS_TIMER = null;
  }
  el.classList.remove("success", "error");
  if(!message){
    el.textContent = "";
    el.style.display = "none";
    return;
  }
  if(type === "success") el.classList.add("success");
  else if(type === "error") el.classList.add("error");
  el.textContent = message;
  el.style.display = "block";
  if(autoHideMs){
    ROOTS_STATUS_TIMER = setTimeout(() => {
      const target = document.getElementById("event-roots-status");
      if(target){
        target.textContent = "";
        target.style.display = "none";
        target.classList.remove("success", "error");
      }
      ROOTS_STATUS_TIMER = null;
    }, autoHideMs);
  }
}

function setRootsControlsDisabled(flag){
  if(!CAN_MANAGE) return;
  document.querySelectorAll('#event-roots-card .manage-action').forEach(btn => {
    btn.disabled = flag;
  });
  const select = document.getElementById("event-root-add-select");
  if(select){
    if(flag){
      select.disabled = true;
    }else{
      select.disabled = false;
      updateAddSelect();
    }
  }
}

function updateAddSelect(){
  if(!CAN_MANAGE) return;
  const select = document.getElementById("event-root-add-select");
  const hint = document.getElementById("event-roots-hint");
  const addBtn = document.getElementById("btn-add-root");
  if(!select) return;

  const available = [];
  ROOT_CHOICES_MAP.forEach(info => {
    if(!EVENT_ROOTS.has(info.id)){
      available.push(info);
    }
  });
  available.sort((a,b)=> (a.name||"").localeCompare(b.name||"", 'fr', {sensitivity:'base'}));

  const current = select.value;
  select.innerHTML = '<option value="">Ajouter un parent…</option>';
  available.forEach(info => {
    const opt = document.createElement('option');
    opt.value = String(info.id);
    opt.textContent = info.name || `Parent ${info.id}`;
    select.appendChild(opt);
  });
  if(current && available.some(info => String(info.id) === current)){
    select.value = current;
  }
  const disabled = (available.length === 0) || ROOTS_SAVING;
  select.disabled = disabled;
  if(addBtn){
    addBtn.disabled = disabled || ROOTS_SAVING;
  }
  if(hint){
    hint.textContent = available.length === 0
      ? "Tous les parents racines sont déjà associés à l'événement."
      : "";
  }
}

function renderManageRoots(){
  if(!CAN_MANAGE) return;
  const holder = document.getElementById("event-roots-list");
  if(!holder) return;
  holder.innerHTML = "";

  if(EVENT_ROOTS.size === 0){
    holder.appendChild(el("div", {class:"muted"}, "Aucun parent sélectionné pour cet événement."));
  } else {
    EVENT_ROOTS.forEach(spec => {
      const node = NODE_MAP.get(spec.id);
      const status = node ? groupStatus(node) : "WAIT";
      const pillClass = status === "OK" ? "pill-ok" : (status === "BAD" ? "pill-bad" : "pill-wait");
      const pill = el("div", {class:`parent-pill ${pillClass}`},
        statusDot(status === "OK", status === "BAD"),
        el("span", {class:"strong"}, spec.name || `Parent ${spec.id}`)
      );
      if(spec.unique_item){
        const qtyVal = (spec.quantity != null)
          ? spec.quantity
          : (spec.unique_quantity != null ? spec.unique_quantity : 1);
        pill.append(
          el("button", {
            class:"btn ghost sm manage-action",
            title:"Modifier la quantité",
            onclick:()=>changeRootQuantity(spec.id)
          }, `Qté: ${qtyVal}`)
        );
      }
      pill.append(
        el("button", {
          class:"btn danger sm manage-action",
          onclick:()=>removeRootFromEvent(spec.id)
        }, "Retirer")
      );
      holder.appendChild(pill);
    });
  }
  updateAddSelect();
}

function syncCurrentRootsFromTree(){
  if(!CAN_MANAGE) return;
  EVENT_ROOTS.clear();
  (TREE||[]).forEach(root => {
    if(!root || !isGroup(root)) return;
    const uniqQty = root.unique_quantity != null && root.unique_quantity !== ''
      ? Number.parseInt(root.unique_quantity, 10)
      : null;
    let selected = null;
    if(root.selected_quantity != null && root.selected_quantity !== ''){
      const parsed = Number.parseInt(root.selected_quantity, 10);
      selected = Number.isNaN(parsed) ? selected : parsed;
    } else if(root.quantity != null && root.quantity !== ''){
      const parsed = Number.parseInt(root.quantity, 10);
      selected = Number.isNaN(parsed) ? selected : parsed;
    } else if(uniqQty != null){
      selected = uniqQty;
    }
    EVENT_ROOTS.set(root.id, {
      id: root.id,
      name: root.name,
      unique_item: !!root.unique_item,
      unique_quantity: Number.isNaN(uniqQty) ? null : uniqQty,
      quantity: Number.isNaN(selected) ? null : selected,
    });
  });
  const slotsChanged = syncSlotsNodesFromRoots();
  renderManageRoots();
  if(slotsChanged){
    renderSlotDisplay();
  }
  renderSlotEditor();
  updateSlotsButtons();
}

async function ensureRootChoicesLoaded(){
  if(!CAN_MANAGE) return;
  if(ROOT_CHOICES_MAP.size > 0){
    updateAddSelect();
    return;
  }
  try{
    const res = await fetch('/stock/roots', {credentials:'include'});
    if(!res.ok) return;
    const data = await res.json();
    if(!Array.isArray(data)) return;
    ROOT_CHOICES_MAP.clear();
    data.forEach(entry => {
      if(!entry) return;
      const id = Number.parseInt(entry.id, 10);
      if(!id) return;
      const max = entry.unique_quantity != null ? Number.parseInt(entry.unique_quantity, 10) : null;
      ROOT_CHOICES_MAP.set(id, {
        id,
        name: entry.name || `Parent ${id}`,
        unique_item: !!entry.unique_item,
        unique_quantity: Number.isNaN(max) ? null : max,
      });
    });
    updateAddSelect();
  }catch(_){ }
}

function promptQuantityForRoot(info, initialValue){
  const label = info && info.name ? info.name : "ce parent";
  const max = info && info.unique_quantity != null ? info.unique_quantity : null;
  let current = (initialValue != null && !Number.isNaN(initialValue))
    ? Number(initialValue)
    : (max != null ? max : 1);
  while(true){
    const input = prompt(`Quantité désirée pour ${label}${max != null ? ` (max ${max})` : ''}`, String(current));
    if(input === null) return null;
    const qty = Number.parseInt(input, 10);
    if(Number.isNaN(qty) || qty < 0){
      alert('Quantité invalide');
      continue;
    }
    if(max != null && qty > max){
      alert(`Quantité supérieure au maximum (${max}).`);
      current = max;
      continue;
    }
    return qty;
  }
}

function buildRootsPayload(){
  const payload = [];
  EVENT_ROOTS.forEach(spec => {
    const entry = {id: spec.id};
    if(spec.unique_item){
      let qty = spec.quantity;
      if(qty == null){
        qty = spec.unique_quantity != null ? spec.unique_quantity : 1;
      }
      entry.quantity = qty;
    } else if(spec.quantity != null){
      entry.quantity = spec.quantity;
    }
    payload.push(entry);
  });
  return payload;
}

async function persistRoots(){
  if(!CAN_MANAGE) return false;
  const payload = buildRootsPayload();
  if(payload.length === 0){
    alert("Sélectionne au moins un parent");
    return false;
  }
  ROOTS_SAVING = true;
  setRootsControlsDisabled(true);
  setRootsStatus("Enregistrement en cours…", "info");
  try{
    const res = await fetch(`/events/${EVENT_ID}/roots`, {
      method:"PUT",
      credentials:"include",
      headers:{"Content-Type":"application/json", "Accept":"application/json"},
      body: JSON.stringify({roots: payload})
    });
    const text = await res.text();
    if(!res.ok){
      setRootsStatus("", "info");
      alert(text || "Impossible d'enregistrer la sélection.");
      return false;
    }
    setRootsStatus("Modifications enregistrées.", "success", 3200);
    return true;
  }catch(_){
    setRootsStatus("", "info");
    alert("Erreur réseau");
    return false;
  }finally{
    ROOTS_SAVING = false;
    setRootsControlsDisabled(false);
  }
}

async function reloadTreeFull(){
  if(FULL_RELOAD_IN_PROGRESS) return;
  FULL_RELOAD_IN_PROGRESS = true;
  try{
    const res = await fetch(`/events/${EVENT_ID}/tree`, {credentials:"include"});
    if(!res.ok) return;
    const latest = await res.json();
    TREE = latest;
    buildUIOnce();
  }catch(_){
  }finally{
    FULL_RELOAD_IN_PROGRESS = false;
  }
}

async function addRootToEvent(rootId){
  if(!CAN_MANAGE || !rootId) return;
  if(EVENT_ROOTS.has(rootId)){
    alert("Ce parent est déjà associé à l'événement.");
    return;
  }
  if(!ROOT_CHOICES_MAP.has(rootId)){
    await ensureRootChoicesLoaded();
  }
  const info = ROOT_CHOICES_MAP.get(rootId);
  if(!info){
    alert("Parent introuvable.");
    return;
  }
  let quantity = null;
  if(info.unique_item){
    const chosen = promptQuantityForRoot(info, info.unique_quantity);
    if(chosen === null) return;
    quantity = chosen;
  }
  const backup = new Map(EVENT_ROOTS);
  EVENT_ROOTS.set(rootId, {
    id: rootId,
    name: info.name,
    unique_item: !!info.unique_item,
    unique_quantity: info.unique_quantity,
    quantity,
  });
  renderManageRoots();
  const ok = await persistRoots();
  if(!ok){
    EVENT_ROOTS.clear();
    backup.forEach((value, key) => EVENT_ROOTS.set(key, value));
    renderManageRoots();
    return;
  }
  await reloadTreeFull();
}

async function removeRootFromEvent(rootId){
  if(!CAN_MANAGE || !EVENT_ROOTS.has(rootId)) return;
  const spec = EVENT_ROOTS.get(rootId);
  const label = spec && spec.name ? spec.name : "ce parent";
  if(!confirm(`Retirer ${label} de l'événement ?`)) return;
  const backup = new Map(EVENT_ROOTS);
  EVENT_ROOTS.delete(rootId);
  renderManageRoots();
  const ok = await persistRoots();
  if(!ok){
    EVENT_ROOTS.clear();
    backup.forEach((value, key) => EVENT_ROOTS.set(key, value));
    renderManageRoots();
    return;
  }
  await reloadTreeFull();
}

async function changeRootQuantity(rootId){
  if(!CAN_MANAGE) return;
  const spec = EVENT_ROOTS.get(rootId);
  if(!spec || !spec.unique_item) return;
  const info = ROOT_CHOICES_MAP.get(rootId) || {name: spec.name, unique_quantity: spec.unique_quantity};
  const current = spec.quantity != null ? spec.quantity : (spec.unique_quantity != null ? spec.unique_quantity : 1);
  const chosen = promptQuantityForRoot(info, current);
  if(chosen === null || chosen === spec.quantity) return;
  const previous = spec.quantity;
  spec.quantity = chosen;
  renderManageRoots();
  const ok = await persistRoots();
  if(!ok){
    spec.quantity = previous;
    renderManageRoots();
    return;
  }
  await reloadTreeFull();
}

/* ---------- Stats ---------- */
function updateChipValue(id, label, value){
  const chip = document.getElementById(id);
  if(!chip) return;
  const labelEl = chip.querySelector(".chip-label");
  const valueEl = chip.querySelector(".chip-value");
  if(labelEl) labelEl.textContent = label;
  if(valueEl) valueEl.textContent = value;
  if(!labelEl && !valueEl){
    chip.textContent = `${label} : ${value}`;
  }
}

function recomputeStats(){
  const items = flattenItems(TREE);
  const total = items.length;
  const ok = items.filter(i=>normStatus(i.last_status)==="OK").length;
  const bad = items.filter(i=>normStatus(i.last_status)==="NOT_OK").length;
  const wait = total - ok - bad;

  updateChipValue("stat-ok", "OK", ok);
  updateChipValue("stat-bad", "Non conformes", bad);
  updateChipValue("stat-wait", "En attente", wait);
  const pct = total? Math.round(ok/total*100) : 0;
  document.getElementById("progress-bar").style.width = pct+"%";
  document.getElementById("progress-text").textContent = `${ok} / ${total} vérifiés`;
}

/* ---------- Rendu ---------- */
function itemStateClass(n){
  const s = normStatus(n.last_status);
  if(s==="OK") return "state-ok";
  if(s==="NOT_OK") return "state-bad";
  return "state-wait";
}
function groupStateClass(n){
  const s = groupStatus(n);
  if(s==="OK") return "state-ok";
  if(s==="BAD") return "state-bad";
  return "state-wait";
}
function statusDot(isOk, isBad){
  return el("span", {class:"status-dot "+(isOk?"dot-ok":(isBad?"dot-bad":"dot-wait"))});
}

function renderItem(n){
  const s = normStatus(n.last_status);
  const statusLbl = s==="OK" ? "✅ OK" : (s==="NOT_OK" ? "❌ Non conforme" : "⏳ En attente");
  const by = n.last_by ? ` (${n.last_by})` : "";
  const actionsEnabled = IS_OPEN && SHOW_VERIFY;
  const targetId = targetNodeId(n);
  const safeId = domSafeId(n.id);
  const qtyValue = (n.selected_quantity != null)
    ? n.selected_quantity
    : (n.quantity != null ? n.quantity : (n.unique_quantity != null ? n.unique_quantity : 1));

  const qtySpan = el("span", {class:"qty", id:`qty-${safeId}`}, `Qté: ${qtyValue}`);
  ITEM_QTY_TXT.set(n.id, qtySpan);

  const statusDiv = el("div", {class:"muted", id:`status-${safeId}`}, `Dernier statut: ${statusLbl}${by}`);
  ITEM_STATUS_TXT.set(n.id, statusDiv);

  const right = SHOW_VERIFY ? el("div", {class:"row"},
    el("button", {class:"btn success", disabled:!actionsEnabled, onclick:()=>verify(targetId,"OK")}, "OK"),
    el("button", {class:"btn ghost", disabled:!actionsEnabled, onclick:()=>verify(targetId,"NOT_OK")}, "Non conforme"),
  ) : null;

  const wrap = el("div", {class:"item "+itemStateClass(n), id:`item-${safeId}`},
    el("div", null,
      el("div", {class:"name"}, statusDot(s==="OK", s==="NOT_OK"), " ", n.name, " ", qtySpan),
      statusDiv
    ),
    right
  );
  ITEM_EL.set(n.id, wrap);
  return wrap;
}

function renderUniqueParentRow(n){
  const s = normStatus(n.last_status);
  const statusLbl = s==="OK" ? "✅ OK" : (s==="NOT_OK" ? "❌ Non conforme" : "⏳ En attente");
  const by = n.last_by ? ` (${n.last_by})` : "";
  const actionsEnabled = IS_OPEN && SHOW_VERIFY;
  const targetId = targetNodeId(n);
  const safeId = domSafeId(n.id);
  const qtyValue = (n.selected_quantity != null) ? n.selected_quantity : (n.quantity != null ? n.quantity : (n.unique_quantity != null ? n.unique_quantity : 1));

  const qtySpan = el("span", {class:"qty", id:`qty-${safeId}`}, `Qté: ${qtyValue}`);
  ITEM_QTY_TXT.set(n.id, qtySpan);

  const statusDiv = el("div", {class:"muted", id:`status-${safeId}`}, `Dernier statut: ${statusLbl}${by}`);
  ITEM_STATUS_TXT.set(n.id, statusDiv);

  const right = SHOW_VERIFY ? el("div", {class:"row"},
    el("button", {class:"btn success", disabled:!actionsEnabled, onclick:()=>verify(targetId,"OK")}, "OK"),
    el("button", {class:"btn ghost", disabled:!actionsEnabled, onclick:()=>verify(targetId,"NOT_OK")}, "Non conforme"),
  ) : null;

  const wrap = el("div", {class:`item unique-parent ${itemStateClass(n)}`, id:`item-${safeId}`},
    el("div", {class:"unique-info"},
      el("div", {class:"name"}, statusDot(s==="OK", s==="NOT_OK"), " Qté: ", qtySpan),
      statusDiv
    ),
    right
  );
  ITEM_EL.set(n.id, wrap);
  return wrap;
}

function renderGroup(n){
  const isRoot = !!n.is_event_root;
  const veh = isRoot
    ? el("span", {class:"vehicle "+(n.charged_vehicle?'on':'off')},
        n.charged_vehicle ? `Chargé : ${formatChargeInfo(n.charged_vehicle_name, n.charged_operator_name)}` : "Non chargé")
    : null;
  if(isRoot) VEH_LABEL.set(n.id, veh);

  let reassortBadge = null;
  if(isRoot){
    reassortBadge = el("span", {
      class:`reassort-note${n.reassort_note?"":" empty"}`,
      id:`reassort-${n.id}`,
    }, n.reassort_note ? `Réassort : ${n.reassort_note}` : "");
    REASSORT_LABEL.set(n.id, reassortBadge);
  }

  if(!COLLAPSED.has(n.id)) COLLAPSED.set(n.id, true);
  const collapsed = !!COLLAPSED.get(n.id);
  const gStatus = groupStatus(n);
  const chev = el("span", {class:"chev", id:`chev-${n.id}`}, collapsed ? "▸" : "▾");
  const headerLeft = el("div", {class:"left"},
    chev,
    statusDot(gStatus==="OK", gStatus==="BAD"),
    el("span", {class:"group-name"}, n.name),
    isRoot ? veh : null,
    isRoot ? reassortBadge : null,
  );

  let btnCharge = null;
  let btnReassort = null;
  if(isRoot && ALLOW_CHARGE){
    btnCharge = el("button", {
      class:"btn xs primary",
      onclick:(e)=>{ e.stopPropagation(); openChargeModal(n.id); }
    }, "Charger");
    CHARGE_BUTTON.set(n.id, btnCharge);

    btnReassort = el("button", {
      class:"btn xs",
      onclick:(e)=>{ e.stopPropagation(); openReassortModal(n.id); }
    }, "Réassort");
    if(!n.charged_vehicle){
      btnReassort.style.display = "none";
    }
    REASSORT_BUTTON.set(n.id, btnReassort);
  }

  const header = el("div", {class:"header toggle"}, headerLeft, el("div", {class:"actions"}, btnCharge, btnReassort));
  header.addEventListener("click", ()=>toggleCollapse(n.id));

  const bodyChildren = [];
  if(isUnique(n)){
    bodyChildren.push(renderUniqueParentRow(n));
  }
  (n.children||[]).forEach(child => {
    bodyChildren.push(renderNode(child));
  });
  const children = el("div", {class:`childs ${collapsed?"collapsed":""}`, id:`childs-${n.id}`}, ...bodyChildren);
  const box = el("div", {class:`node ${groupStateClass(n)}`, id:`node-${n.id}`}, header, children);
  GROUP_EL.set(n.id, box);
  if(isRoot){
    updateChargeButtonState(n.id);
    updateReassortUI(n.id);
  }
  return box;
}
function renderNode(n){ return isGroup(n) ? renderGroup(n) : renderItem(n); }

function updateChargeButtonState(parentId){
  const btn = CHARGE_BUTTON.get(parentId);
  const node = NODE_MAP.get(parentId);
  if(!btn || !node){ return; }
  const enable = canChargeGroup(node);
  btn.disabled = !enable;
  if(!enable){
    btn.title = IS_OPEN ? "Tous les éléments doivent être OK" : "Événement clôturé";
  } else {
    btn.title = "";
  }
}

function updateReassortUI(parentId){
  const node = NODE_MAP.get(parentId);
  const badge = REASSORT_LABEL.get(parentId);
  if(badge){
    const note = node && node.reassort_note ? node.reassort_note : "";
    badge.textContent = note ? `Réassort : ${note}` : "";
    badge.classList.toggle("empty", !note);
  }
  const btn = REASSORT_BUTTON.get(parentId);
  if(btn){
    const visible = !!(node && node.charged_vehicle && ALLOW_CHARGE && IS_OPEN);
    btn.style.display = visible ? "" : "none";
  }
}

function updateActionButtons(){
  const enable = IS_OPEN && SHOW_VERIFY;
  ITEM_EL.forEach(box => {
    box.querySelectorAll("button").forEach(btn => { btn.disabled = !enable; });
  });
}
function updateStatusUI(){
  const badge = document.getElementById("status-badge");
  if(badge){
    const status = IS_OPEN ? "OPEN" : "CLOSED";
    badge.textContent = `Statut : ${status}`;
    badge.setAttribute("data-status", status);
  }
  const btn = document.getElementById("btn-close");
  if(btn) btn.textContent = IS_OPEN ? "Clôturer l'événement" : "Réouvrir l'événement";
  if(ALLOW_CHARGE){
    NODE_MAP.forEach(n => {
      if(n && n.is_event_root){
        updateChargeButtonState(n.id);
        updateReassortUI(n.id);
      }
    });
  }
}

function buildUIOnce(){
  const root = document.getElementById("tree");
  if(!root) return;
  root.innerHTML = "";
  NODE_MAP.clear();
  GROUP_EL.clear();
  ITEM_EL.clear();
  ITEM_STATUS_TXT.clear();
  ITEM_QTY_TXT.clear();
  VEH_LABEL.clear();
  CHARGE_BUTTON.clear();
  REASSORT_LABEL.clear();
  REASSORT_BUTTON.clear();
  indexTree(TREE);
  (TREE||[]).forEach(n => root.appendChild(renderNode(n)));
  buildParentsBar();
  recomputeStats();
  updateActionButtons();
  updateStatusUI();
  if(CAN_MANAGE){
    syncCurrentRootsFromTree();
  }
}

/* ---------- MAJ incrémentales ---------- */
function applyItemDelta(local, incoming){
  // normalise & applique les nouvelles valeurs
  local.last_status = normStatus(incoming.last_status || "PENDING");
  local.last_by = incoming.last_by || "";
  if(incoming.quantity != null) local.quantity = incoming.quantity;
  if(typeof incoming.selected_quantity !== "undefined") local.selected_quantity = incoming.selected_quantity;
  if(typeof incoming.unique_quantity !== "undefined") local.unique_quantity = incoming.unique_quantity;
  if(typeof incoming.target_node_id !== "undefined") local.target_node_id = incoming.target_node_id;
  if(typeof incoming.unique_from_parent !== "undefined") local.unique_from_parent = incoming.unique_from_parent;

  const box = ITEM_EL.get(local.id);
  const statusDiv = ITEM_STATUS_TXT.get(local.id);
  const qtySpan = ITEM_QTY_TXT.get(local.id);
  if(!box) return;

  // 1) Classe visuelle de l'item (fond/contour)
  box.classList.remove("state-ok","state-bad","state-wait");
  box.classList.add(itemStateClass(local));

  // 2) ⚡️ Met à jour la pastille (dot) de l'item SANS F5
  const dot = box.querySelector(".status-dot");
  const s = normStatus(local.last_status);
  if(dot){
    dot.classList.remove("dot-ok","dot-bad","dot-wait");
    dot.classList.add(s==="OK" ? "dot-ok" : (s==="NOT_OK" ? "dot-bad" : "dot-wait"));
  }

  // 3) Texte d'état & quantité
  const label = s==="OK" ? "✅ OK" : (s==="NOT_OK" ? "❌ Non conforme" : "⏳ En attente");
  if(statusDiv) statusDiv.textContent = `Dernier statut: ${label}${local.last_by ? " ("+local.last_by+")" : ""}`;
  if(qtySpan){
    const qtyVal = (local.selected_quantity != null)
      ? local.selected_quantity
      : (local.quantity != null ? local.quantity : (local.unique_quantity != null ? local.unique_quantity : 1));
    qtySpan.textContent = `Qté: ${qtyVal}`;
  }
}

function applyGroupDelta(local, incoming){
  if(local.is_event_root && (typeof incoming.charged_vehicle !== "undefined")){
    local.charged_vehicle = !!incoming.charged_vehicle;
    if(typeof incoming.charged_vehicle_name !== "undefined"){
      local.charged_vehicle_name = incoming.charged_vehicle_name || null;
    }
    if(typeof incoming.operator_name !== "undefined"){
      local.charged_operator_name = incoming.operator_name || null;
    } else if(typeof incoming.charged_operator_name !== "undefined"){
      local.charged_operator_name = incoming.charged_operator_name || null;
    }
  }
  if(local.is_event_root && (typeof incoming.reassort_note !== "undefined")){
    local.reassort_note = incoming.reassort_note || null;
  }
  if(local.is_event_root && !local.charged_vehicle){
    local.reassort_note = null;
  }
  if(local.is_event_root){
    if(!local.charged_vehicle){
      local.charged_vehicle_name = null;
      local.charged_operator_name = null;
    }
    const lab = VEH_LABEL.get(local.id);
    if(lab){
      lab.classList.toggle("on", !!local.charged_vehicle);
      lab.classList.toggle("off", !local.charged_vehicle);
      lab.textContent = local.charged_vehicle
        ? `Chargé : ${formatChargeInfo(local.charged_vehicle_name, local.charged_operator_name)}`
        : "Non chargé";
    }
    updateReassortUI(local.id);
  }
  const box = GROUP_EL.get(local.id);
  if(!box) return;

  // Couleurs de panneau
  box.classList.remove("state-ok","state-bad","state-wait");
  box.classList.add(groupStateClass(local));

  // Pastille (dot) d'en-tête du groupe
  const dot = box.querySelector(".status-dot");
  if(dot){
    dot.classList.remove("dot-ok","dot-bad","dot-wait");
    const gs = groupStatus(local);
    dot.classList.add(gs==="OK" ? "dot-ok" : (gs==="BAD" ? "dot-bad" : "dot-wait"));
  }
}

function syncTreeIncoming(incomingRoots){
  (incomingRoots||[]).forEach(function recInc(nInc){
    const nLoc = NODE_MAP.get(nInc.id);
    if(!nLoc) return;
    if(isUnique(nLoc)){
      applyItemDelta(nLoc, nInc);
      if(nLoc.is_event_root){
        nLoc.charged_vehicle = !!nInc.charged_vehicle;
        nLoc.charged_vehicle_name = (typeof nInc.charged_vehicle_name !== "undefined" ? nInc.charged_vehicle_name : nLoc.charged_vehicle_name) || null;
        if(typeof nInc.operator_name !== "undefined"){
          nLoc.charged_operator_name = nInc.operator_name || null;
        } else if(typeof nInc.charged_operator_name !== "undefined"){
          nLoc.charged_operator_name = nInc.charged_operator_name || null;
        }
        if(typeof nInc.reassort_note !== "undefined"){
          nLoc.reassort_note = nInc.reassort_note || null;
        }
      }
      applyGroupDelta(nLoc, nInc);
      (nInc.children||[]).forEach(recInc);
    } else if(isItem(nLoc)){
      applyItemDelta(nLoc, nInc);
    } else {
      if(nLoc.is_event_root){
        nLoc.charged_vehicle = !!nInc.charged_vehicle;
        nLoc.charged_vehicle_name = (typeof nInc.charged_vehicle_name !== "undefined" ? nInc.charged_vehicle_name : nLoc.charged_vehicle_name) || null;
        if(typeof nInc.operator_name !== "undefined"){
          nLoc.charged_operator_name = nInc.operator_name || null;
        } else if(typeof nInc.charged_operator_name !== "undefined"){
          nLoc.charged_operator_name = nInc.charged_operator_name || null;
        }
        if(typeof nInc.reassort_note !== "undefined"){
          nLoc.reassort_note = nInc.reassort_note || null;
        }
      }
      (nInc.children||[]).forEach(recInc);
      applyGroupDelta(nLoc, nInc);
    }
  });
  updateParentsBarOnly();
  recomputeStats();
  updateActionButtons();
  if(CAN_MANAGE){
    renderManageRoots();
  }
}

/* ---------- Barre Parents ---------- */
function buildParentsBar(){
  const holder = document.getElementById("parents-bar");
  if(!holder) return;
  holder.innerHTML = "";
  const parents = (TREE||[]).filter(n => isGroup(n));
  parents.forEach(p => {
    const s = groupStatus(p);
    const pillClass = s==="OK" ? "pill-ok" : (s==="BAD" ? "pill-bad" : "pill-wait");
    const reassortChip = p.reassort_note ? el("span", {class:"reassort-chip"}, `Réassort : ${p.reassort_note}`) : null;
    const pill = el("div", {class:"parent-pill "+pillClass, onclick:()=>scrollToParent(p.id)},
      statusDot(s==="OK", s==="BAD"),
      el("span", {class:"strong"}, p.name),
      p.charged_vehicle ? el("span", {class:"vehicle on"}, formatChargeInfo(p.charged_vehicle_name, p.charged_operator_name)) : null,
      reassortChip
    );
    holder.appendChild(pill);
  });
}
function updateParentsBarOnly(){
  buildParentsBar();
}
function setCollapseState(id, collapsed){
  const value = !!collapsed;
  COLLAPSED.set(id, value);
  const cont = document.getElementById("childs-"+id);
  if(cont) cont.classList.toggle("collapsed", value);
  const chev = document.getElementById("chev-"+id);
  if(chev) chev.textContent = value ? "▸" : "▾";
}
function toggleCollapse(id){
  const current = COLLAPSED.has(id) ? !!COLLAPSED.get(id) : false;
  setCollapseState(id, !current);
}
function scrollToParent(id){
  setCollapseState(id, false);
  const target = document.getElementById("node-"+id);
  if(!target) return;
  target.scrollIntoView({behavior:"smooth", block:"start"});
  setTimeout(()=>{ window.scrollBy({top:-70, left:0, behavior:"instant"}); }, 300);
}

/* ---------- API ---------- */
async function refreshTree(){
  if(FULL_RELOAD_IN_PROGRESS || ROOTS_SAVING) return;
  try{
    const r = await fetch(`/events/${EVENT_ID}/tree`, {credentials:"include"});
    if(!r.ok) return;
    const latest = await r.json();
    syncTreeIncoming(latest);
  }catch(_){}
}
function verify(nodeId, status){
  const payload = { node_id: nodeId, status, verifier_name: CURRENT_USER || "op" };
  fetch(`/events/${EVENT_ID}/verify`, {
    method:"POST", credentials:"include",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  })
  .then(res=>res.ok?refreshTree():res.text().then(t=>alert(t)))
  .catch(()=>{});
}

/* ---------- Charger / Réassort ---------- */
function closeChargeModal(){
  document.getElementById("charge-modal")?.remove();
  CHARGE_TARGET = null;
}

function openChargeModal(parentId){
  if(!ALLOW_CHARGE) return;
  const node = NODE_MAP.get(parentId);
  if(!node) return;
  if(!IS_OPEN){ alert("Événement clôturé."); return; }
  if(!canChargeGroup(node)){ alert("Impossible : tous les éléments doivent être OK."); return; }
  closeChargeModal();
  CHARGE_TARGET = parentId;
  const modal = el("div", {id:"charge-modal", class:"modal-back"},
    el("div", {class:"modal-card"},
      el("div", {class:"title"}, "Charger le parent"),
      el("label", {for:"veh-name"}, "Nom du véhicule"),
      el("input", {id:"veh-name", placeholder:"Ex : VSAV-2", value: node.charged_vehicle_name || ""}),
      el("div", {class:"muted", style:"margin-top:8px"}, `Opérateur : ${CURRENT_USER || "—"}`),
      el("div", {class:"modal-actions"},
        el("button", {class:"btn ghost", onclick:closeChargeModal}, "Annuler"),
        el("button", {class:"btn primary", onclick:confirmCharge}, "Confirmer")
      )
    )
  );
  document.body.appendChild(modal);
  setTimeout(()=>document.getElementById("veh-name")?.focus(), 10);
}

function confirmCharge(){
  const veh = (document.getElementById("veh-name")?.value || "").trim();
  if(!veh){ alert("Merci d’indiquer le nom du véhicule."); return; }
  const targetId = CHARGE_TARGET;
  const payload = {
    node_id: targetId,
    charged_vehicle: true,
    vehicle_name: veh,
    operator_name: CURRENT_USER || "",
  };
  fetch(`/events/${EVENT_ID}/parent-status`, {
    method:"POST",
    credentials:"include",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  })
    .then(async res => {
      if(!res.ok){ const txt = await res.text(); throw new Error(txt || "Impossible de charger le parent."); }
      return res.json().catch(()=>({}));
    })
    .then(()=>{
      const node = NODE_MAP.get(targetId);
      if(node){
        node.charged_vehicle = true;
        node.charged_vehicle_name = veh;
        node.charged_operator_name = CURRENT_USER || null;
      }
      closeChargeModal();
      updateChargeButtonState(targetId);
      updateReassortUI(targetId);
      refreshTree();
    })
    .catch(err => alert(err.message || "Erreur réseau"));
}

function closeReassortModal(){
  document.getElementById("reassort-modal")?.remove();
  REASSORT_TARGET = null;
}

function openReassortModal(parentId){
  if(!ALLOW_CHARGE) return;
  const node = NODE_MAP.get(parentId);
  if(!node) return;
  if(!IS_OPEN){ alert("Événement clôturé."); return; }
  if(!node.charged_vehicle){ alert("Parent non chargé."); return; }
  closeReassortModal();
  REASSORT_TARGET = parentId;
  const modal = el("div", {id:"reassort-modal", class:"modal-back"},
    el("div", {class:"modal-card"},
      el("div", {class:"title"}, `Réassort – ${node.name}`),
      el("label", {for:"reassort-note"}, "Commentaire de réassort"),
      el("textarea", {id:"reassort-note", placeholder:"Ex : Ajouter 2 lots supplémentaires"}, node.reassort_note || ""),
      el("div", {class:"muted", style:"margin-top:8px"}, "Laisser vide pour supprimer le texte."),
      el("div", {class:"modal-actions"},
        el("button", {class:"btn ghost", onclick:closeReassortModal}, "Annuler"),
        el("button", {class:"btn primary", onclick:confirmReassort}, "Enregistrer")
      )
    )
  );
  document.body.appendChild(modal);
  setTimeout(()=>document.getElementById("reassort-note")?.focus(), 10);
}

function confirmReassort(){
  const textarea = document.getElementById("reassort-note");
  const note = (textarea?.value || "").trim();
  const targetId = REASSORT_TARGET;
  fetch(`/events/${EVENT_ID}/parent-reassort`, {
    method:"POST",
    credentials:"include",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify({ node_id: targetId, note })
  })
    .then(async res => {
      if(!res.ok){ const txt = await res.text(); throw new Error(txt || "Impossible d’enregistrer le réassort."); }
      return res.json().catch(()=>({}));
    })
    .then(()=>{
      const node = NODE_MAP.get(targetId);
      if(node){
        node.reassort_note = note || null;
        updateReassortUI(targetId);
        buildParentsBar();
      }
      closeReassortModal();
      refreshTree();
    })
    .catch(err => alert(err.message || "Erreur réseau"));
}

/* ---------- Boutons haut ---------- */
document.getElementById("btn-share").addEventListener("click", ()=>{
  fetch(`/events/${EVENT_ID}/share-link`, {method:"POST", credentials:"include"})
    .then(r=>r.json())
    .then(res=>{
      if(res && res.url){
        const absolute = location.origin + res.url;
        navigator.clipboard.writeText(absolute).catch(()=>{});
        alert("Lien secouristes copié : " + absolute);
      }else{
        alert("Impossible de générer le lien.");
      }
    })
    .catch(()=> alert("Erreur réseau"));
});

document.getElementById("btn-close").addEventListener("click", ()=>{
  const nextStatus = IS_OPEN ? "CLOSED" : "OPEN";
  fetch(`/events/${EVENT_ID}/status`, {
    method:"PATCH", credentials:"include",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify({status: nextStatus})
  })
  .then(res => {
    if(!res.ok){
      return res.text().then(txt => { throw new Error(txt || "Impossible de mettre à jour le statut."); });
    }
    return res.json().catch(()=>null);
  })
  .then(()=>{
    IS_OPEN = (nextStatus === "OPEN");
    updateActionButtons();
    updateStatusUI();
    refreshTree();
  })
  .catch(err => {
    alert(err.message || "Erreur réseau");
  });
});

/* ---------- Init (polling, comme avant) ---------- */
(function init(){
  renderSlotDisplay();
  if(CAN_MANAGE){
    renderSlotEditor();
    setupSlotsEditor();
  }
  buildUIOnce();
  if(CAN_MANAGE){
    ensureRootChoicesLoaded();
    const addBtn = document.getElementById("btn-add-root");
    if(addBtn){
      addBtn.addEventListener("click", async () => {
        const select = document.getElementById("event-root-add-select");
        if(!select) return;
        const value = Number.parseInt(select.value, 10);
        if(!value){
          alert("Sélectionne un parent à ajouter.");
          return;
        }
        await addRootToEvent(value);
        select.value = "";
      });
    }
  }
  setInterval(refreshTree, 2000);
})();
</script>
{% endblock %}
