{% extends "base.html" %}
{% set status_obj = event.status %}
{% set status_name = status_obj.name if status_obj is not none and status_obj.__class__.__name__ != "str" else status_obj %}
{% set status_upper = (status_name or "")|string|upper %}
{% set status_readable = status_upper %}
{% set event_date = event.date.strftime("%d/%m/%Y") if event.date else None %}
{% block content %}

<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
  .wrap{max-width:1100px;margin:0 auto;padding:14px}
  .topbar{display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between;padding:14px;border:1px solid var(--border);border-radius:14px;background:var(--bg-2);box-shadow:var(--shadow);position:sticky;top:8px;z-index:10}
  .topbar .left{display:flex;flex-direction:column;gap:6px}
  .topbar .title{font-weight:800;font-size:20px}
  .topbar .meta{display:flex;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:14px}
  .status-badge{border:1px solid var(--border);border-radius:999px;padding:6px 12px;font-weight:700;background:#101c2e;color:#cfe2ff}
  .topbar .actions{display:flex;gap:8px;flex-wrap:wrap}
  .card-like{margin-top:14px;padding:14px;border:1px solid var(--border);border-radius:16px;background:var(--bg-2);box-shadow:var(--shadow)}
  .card-like .title{font-weight:700;font-size:18px}
  .stats-chipbar{display:flex;gap:10px;flex-wrap:wrap;margin-top:6px}
  .chip{padding:4px 10px;border-radius:999px;font-weight:700;font-size:13px;border:1px solid var(--border)}
  .chip.ok{background:#0e2a24;color:#bff3e7;border-color:#1d6e5d}
  .chip.bad{background:#2a0e14;color:#ffd5dc;border-color:#75212f}
  .chip.wait{background:#101c2e;color:#b7c7dc;border-color:#24344f}
  .progress{height:8px;background:rgba(255,255,255,.08);border-radius:8px;overflow:hidden;margin-top:10px}
  .progress > div{height:100%;width:0;background:var(--pc-orange);transition:width .25s ease}
  .legend{color:var(--muted);font-size:13px}
  .parents-bar{display:flex;gap:10px;overflow:auto;padding:4px 2px}
  .parent-pill{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:999px;border:1px solid var(--border);background:#0f1a2a;color:var(--text);white-space:nowrap;cursor:pointer;user-select:none;transition:transform .08s,border-color .08s,background .08s}
  .parent-pill:hover{transform:translateY(-1px)}
  .pill-ok{border-color:#1d6e5d;background:#0e2a24;color:#bff3e7}
  .pill-bad{border-color:#75212f;background:#2a0e14;color:#ffd5dc}
  .pill-wait{border-color:#24344f;background:#101c2e;color:#b7c7dc}
  .node{border:1px solid var(--border);border-radius:12px;padding:12px;margin:12px 0;background:#0f1a2a}
  .state-ok{border-color:var(--success)!important;background:radial-gradient(600px 200px at top left, rgba(18,184,134,.15), transparent),#0f1e2f;box-shadow:0 0 0 1px rgba(18,184,134,.35) inset,0 0 18px rgba(18,184,134,.15)}
  .state-bad{border-color:var(--danger)!important;background:radial-gradient(600px 200px at top left, rgba(255,107,107,.12), transparent),#0f1a27;box-shadow:0 0 0 1px rgba(255,107,107,.30) inset,0 0 18px rgba(255,107,107,.12)}
  .state-wait{border-color:var(--border)!important;background:radial-gradient(600px 200px at top left, rgba(45,123,191,.08), transparent),var(--bg-2)}
  .header{display:flex;align-items:center;gap:12px;justify-content:space-between;padding:10px 12px;border-radius:10px}
  .header .left{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .group-title{font-weight:800}
  .vehicle{font-size:12px;padding:2px 8px;border-radius:8px;border:1px dashed var(--border)}
  .vehicle.on{background:#0e2a24;color:#bff3e7;border-color:#1d6e5d}
  .vehicle.off{background:#101c2e;color:#b7c7dc;border-color:#24344f}
  .status-dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:8px;vertical-align:middle}
  .dot-ok{background:var(--success)} .dot-bad{background:var(--danger)} .dot-wait{background:#37527a}
  .childs{padding:10px 8px 6px 28px}
  .item{display:flex;align-items:flex-start;gap:14px;justify-content:space-between;padding:14px;border-radius:12px;margin:12px 0;border:1px solid var(--border);background:#0f1726}
  .item .name{font-weight:700}
  .item .qty{opacity:.9;font-size:12px;border:1px dashed var(--border);border-radius:8px;padding:2px 8px}
  .item .muted{font-size:13px;color:var(--muted)}
  @media (max-width: 700px){.topbar{gap:12px}.topbar .left{width:100%}.topbar .actions{width:100%;justify-content:flex-start}.childs{padding-left:14px}}
</style>

<div class="wrap">
  <div class="topbar">
    <div class="left">
      <div class="title">{{ event.name }}</div>
      <div class="meta">
        {% if event_date %}<span>Le {{ event_date }}</span>{% endif %}
        <span id="status-badge" class="status-badge">Statut : {{ status_readable }}</span>
      </div>
    </div>
    <div class="actions">
      <button class="btn ghost" id="btn-share">Lien secouristes</button>
      <button class="btn danger" id="btn-close" {% if status_readable != "OPEN" %}disabled{% endif %}>Cloturer</button>
    </div>
  </div>

  <div class="card-like stats-card">
    <div class="title">Progression</div>
    <div class="stats-chipbar">
      <span class="chip ok" id="stat-ok">OK : 0</span>
      <span class="chip bad" id="stat-bad">Non conformes : 0</span>
      <span class="chip wait" id="stat-wait">En attente : 0</span>
    </div>
    <div class="progress"><div id="progress-bar"></div></div>
    <div class="muted" id="progress-text" style="margin-top:6px;">0 / 0 vAcrifiAcs</div>
  </div>

  <div class="card-like">
    <div class="title">Parents</div>
    <div id="parents-bar" class="parents-bar"></div>
  </div>

  <div class="card-like">
    <div class="row space-between">
      <div class="title">Materiel</div>
      <div class="legend">Vert = tout OK, Rouge = non conforme, Bleu = en attente</div>
    </div>
    <div id="tree"></div>
  </div>
</div>

<script>
const EVENT_ID = {{ event.id }};
const CURRENT_USER = {{ (current_user.username if current_user.is_authenticated else "")|tojson }};
const STATUS_LABEL = {{ ((event.status.name if event.status is not none and event.status.__class__.__name__ != "str" else event.status) or "")|string|upper|tojson }};
let IS_OPEN = STATUS_LABEL === "OPEN";
const HAS_SOCKET_IO = typeof io !== "undefined";
let TREE = {{ tree|tojson }};

const formatVehicleLabel = (vehicleName, operatorName) => {
  const vehicle = (vehicleName || "").trim();
  const operator = (operatorName || "").trim();
  if(vehicle && operator){
    return `Chargé : ${vehicle} (par ${operator})`;
  }
  if(vehicle){
    return `Chargé : ${vehicle}`;
  }
  if(operator){
    return `Chargé par ${operator}`;
  }
  return "Chargé";
};

const extractVehicleMeta = (source) => {
  const result = {
    vehicle: source?.charged_vehicle_name ?? null,
    operator: source?.charged_vehicle_operator ?? null,
  };
  const rawComment = source && source.comment;
  if((!result.vehicle || !result.operator) && rawComment){
    try {
      const data = typeof rawComment === 'string' ? JSON.parse(rawComment) : rawComment;
      result.vehicle = result.vehicle || data?.vehicle_name || null;
      result.operator = result.operator || data?.operator_name || data?.operator || null;
    } catch (_) {}
  }
  return result;
};

let socketClient = null;
let socketInitialized = false;
let socketRefreshTimer = null;
let refreshInFlight = false;
let refreshQueued = false;

function scheduleRealtimeRefresh(delay = 250){
  if(socketRefreshTimer) return;
  socketRefreshTimer = setTimeout(()=>{
    socketRefreshTimer = null;
    refreshTree();
  }, delay);
}

function setupSocket(){
  if(socketInitialized || !HAS_SOCKET_IO){
    return;
  }
  socketInitialized = true;
  socketClient = io("/events", { withCredentials: true });
  socketClient.on("connect", ()=>{
    socketClient.emit("join_event", { event_id: EVENT_ID });
  });
  socketClient.on("event_update", payload => {
    if(!payload || payload.event_id !== EVENT_ID){
      return;
    }
    if(payload.type === "joined"){
      return;
    }
    if(payload.type === "status" && payload.status){
      const statusUpper = String(payload.status).toUpperCase();
      IS_OPEN = statusUpper === "OPEN";
      const badge = document.getElementById("status-badge");
      if(badge){
        badge.textContent = `Statut : ${statusUpper}`;
      }
      if(!IS_OPEN){
        ITEM_EL.forEach(box=>{
          box.querySelectorAll("button").forEach(btn => btn.disabled = true);
        });
      }
    }
    scheduleRealtimeRefresh(payload.type === "status" ? 50 : 200);
  });
}

/* ========= State ========= */
const NODE_MAP = new Map();
const GROUP_EL = new Map();
const ITEM_EL  = new Map();
const ITEM_STATUS_TXT = new Map();
const ITEM_QTY_TXT = new Map();
const VEH_LABEL = new Map();

/* ---------- Utils ---------- */
function indexTree(nodes){
  (nodes||[]).forEach(function rec(n){
    NODE_MAP.set(n.id, n);
    (n.children||[]).forEach(rec);
  });
}
function el(tag, attrs={}, ...children){
  const e = document.createElement(tag);
  for(const [k,v] of Object.entries(attrs||{})){
    if(k==="class") e.className = v;
    else if(k==="html") e.innerHTML = v;
    else if(k.startsWith("on") && typeof v==="function") e.addEventListener(k.slice(2), v);
    else e.setAttribute(k, v);
  }
  for(const c of children){ if(c!=null) e.append(c.nodeType?c:document.createTextNode(c)); }
  return e;
}
const isItem = n => (n.type||"").toUpperCase()==="ITEM";
const isGroup = n => (n.type||"").toUpperCase()==="GROUP";
function normStatus(s){
  s = (s||"").toUpperCase();
  if(s==="OK") return "OK";
  if(s==="NOT_OK" || s==="NOK" || s==="KO" || s==="NOT-OK" || s==="NOTOK") return "NOT_OK";
  return "PENDING";
}

/* ---------- Statuts ---------- */
function groupAllOk(n){
  let ok = true, hasItem=false;
  (function rec(x){
    if(isItem(x)){ hasItem=true; ok = ok && (normStatus(x.last_status)==="OK"); }
    (x.children||[]).forEach(rec);
  })(n);
  return hasItem && ok;
}
function groupHasBad(n){
  let bad = false;
  (function rec(x){
    if(isItem(x) && normStatus(x.last_status)==="NOT_OK") bad = true;
    (x.children||[]).forEach(rec);
  })(n);
  return bad;
}
function groupStatus(n){
  if(groupAllOk(n)) return "OK";
  if(groupHasBad(n)) return "BAD";
  return "WAIT";
}
function flattenItems(nodes){
  const out=[]; (nodes||[]).forEach(function rec(n){
    if(isItem(n)) out.push(n);
    (n.children||[]).forEach(rec);
  });
  return out;
}

/* ---------- Stats ---------- */
function recomputeStats(){
  const items = flattenItems(TREE);
  const total = items.length;
  const ok = items.filter(i=>normStatus(i.last_status)==="OK").length;
  const bad = items.filter(i=>normStatus(i.last_status)==="NOT_OK").length;
  const wait = total - ok - bad;

  document.getElementById("stat-ok").textContent = `OK : ${ok}`;
  document.getElementById("stat-bad").textContent = `Non conformes : ${bad}`;
  document.getElementById("stat-wait").textContent = `En attente : ${wait}`;
  const pct = total? Math.round(ok/total*100) : 0;
  document.getElementById("progress-bar").style.width = pct+"%";
  document.getElementById("progress-text").textContent = `${ok} / ${total} vérifiés`;
}

/* ---------- Rendu ---------- */
function itemStateClass(n){
  const s = normStatus(n.last_status);
  if(s==="OK") return "state-ok";
  if(s==="NOT_OK") return "state-bad";
  return "state-wait";
}
function groupStateClass(n){
  const s = groupStatus(n);
  if(s==="OK") return "state-ok";
  if(s==="BAD") return "state-bad";
  return "state-wait";
}
function statusDot(isOk, isBad){
  return el("span", {class:"status-dot "+(isOk?"dot-ok":(isBad?"dot-bad":"dot-wait"))});
}

function renderItem(n){
  const s = normStatus(n.last_status);
  const statusLbl = s==="OK" ? "✅ OK" : (s==="NOT_OK" ? "❌ Non conforme" : "⏳ En attente");
  const by = n.last_by ? ` (${n.last_by})` : "";
  const actionsEnabled = IS_OPEN;

  const qtySpan = el("span", {class:"qty", id:`qty-${n.id}`}, `Qté: ${n.quantity ?? 1}`);
  ITEM_QTY_TXT.set(n.id, qtySpan);

  const statusDiv = el("div", {class:"muted", id:`status-${n.id}`}, `Dernier statut: ${statusLbl}${by}`);
  ITEM_STATUS_TXT.set(n.id, statusDiv);

  const right = el("div", {class:"row"},
    el("button", {class:"btn success", disabled:!actionsEnabled, onclick:()=>verify(n.id,"OK")}, "OK"),
    el("button", {class:"btn ghost", disabled:!actionsEnabled, onclick:()=>verify(n.id,"NOT_OK")}, "Non conforme"),
  );

  const wrap = el("div", {class:"item "+itemStateClass(n), id:`item-${n.id}`},
    el("div", null,
      el("div", {class:"name"}, statusDot(s==="OK", s==="NOT_OK"), " ", n.name, " ", qtySpan),
      statusDiv
    ),
    right
  );
  ITEM_EL.set(n.id, wrap);
  return wrap;
}

function renderGroup(n){
  const meta = extractVehicleMeta(n);
  n.charged_vehicle_name = meta.vehicle ?? null;
  n.charged_vehicle_operator = meta.operator ?? null;

  // Badge véhicule (affiché sur racines si présent dans le tree)
  const vehLabel = n.charged_vehicle ? formatVehicleLabel(meta.vehicle, meta.operator) : "Non chargé";
  const veh = el("span", {class:"vehicle "+(n.charged_vehicle?"on":"off")}, n.charged_vehicle ? vehLabel : "Non chargé");
  if(n.is_event_root){
    VEH_LABEL.set(n.id, veh);
  } else if(VEH_LABEL.has(n.id)){
    VEH_LABEL.delete(n.id);
  }

  const headerLeft = el("div", {class:"name"},
    statusDot(groupStatus(n)==="OK", groupStatus(n)==="BAD"), " ", n.name,
    n.is_event_root ? veh : null
  );
  const header = el("div", {class:"header"}, headerLeft);

  // ❌ Aucun bouton “Charger” ici (réservé à la page publique)
  const children = el("div", {class:"childs"}, ...(n.children||[]).map(renderNode));
  const box = el("div", {class:`node ${groupStateClass(n)}`, id:`node-${n.id}`}, header, children);
  GROUP_EL.set(n.id, box);
  return box;
}
function renderNode(n){ return isGroup(n) ? renderGroup(n) : renderItem(n); }

function buildUIOnce(){
  const root = document.getElementById("tree");
  root.innerHTML = "";
  indexTree(TREE);
  (TREE||[]).forEach(n => root.appendChild(renderNode(n)));
  buildParentsBar();
  recomputeStats();
}

/* ---------- MAJ incrémentales ---------- */
function applyItemDelta(local, incoming){
  // normalise & applique les nouvelles valeurs
  local.last_status = normStatus(incoming.last_status || "PENDING");
  local.last_by = incoming.last_by || "";
  if(incoming.quantity != null) local.quantity = incoming.quantity;

  const box = ITEM_EL.get(local.id);
  const statusDiv = ITEM_STATUS_TXT.get(local.id);
  const qtySpan = ITEM_QTY_TXT.get(local.id);
  if(!box) return;

  // 1) Classe visuelle de l'item (fond/contour)
  box.classList.remove("state-ok","state-bad","state-wait");
  box.classList.add(itemStateClass(local));

  // 2) ⚡️ Met à jour la pastille (dot) de l'item SANS F5
  const dot = box.querySelector(".status-dot");
  const s = normStatus(local.last_status);
  if(dot){
    dot.classList.remove("dot-ok","dot-bad","dot-wait");
    dot.classList.add(s==="OK" ? "dot-ok" : (s==="NOT_OK" ? "dot-bad" : "dot-wait"));
  }

  // 3) Texte d'état & quantité
  const label = s==="OK" ? "✅ OK" : (s==="NOT_OK" ? "❌ Non conforme" : "⏳ En attente");
  if(statusDiv) statusDiv.textContent = `Dernier statut: ${label}${local.last_by ? " ("+local.last_by+")" : ""}`;
  if(qtySpan) qtySpan.textContent = `Qté: ${local.quantity ?? 1}`;
}

function applyGroupDelta(local, incoming){
  if(typeof incoming.charged_vehicle !== "undefined"){
    local.charged_vehicle = !!incoming.charged_vehicle;
    const meta = extractVehicleMeta(incoming);
    local.charged_vehicle_name = meta.vehicle ?? null;
    local.charged_vehicle_operator = meta.operator ?? null;
    const lab = VEH_LABEL.get(local.id);
    if(lab){
      lab.classList.toggle("on", !!local.charged_vehicle);
      lab.classList.toggle("off", !local.charged_vehicle);
      lab.textContent = local.charged_vehicle ? formatVehicleLabel(local.charged_vehicle_name, local.charged_vehicle_operator) : "Non chargé";
    }
  }
  const box = GROUP_EL.get(local.id);
  if(!box) return;

  // Couleurs de panneau
  box.classList.remove("state-ok","state-bad","state-wait");
  box.classList.add(groupStateClass(local));

  // Pastille (dot) d'en-tête du groupe
  const dot = box.querySelector(".status-dot");
  if(dot){
    dot.classList.remove("dot-ok","dot-bad","dot-wait");
    const gs = groupStatus(local);
    dot.classList.add(gs==="OK" ? "dot-ok" : (gs==="BAD" ? "dot-bad" : "dot-wait"));
  }
}

function syncTreeIncoming(incomingRoots){
  (incomingRoots||[]).forEach(function recInc(nInc){
    const nLoc = NODE_MAP.get(nInc.id);
    if(!nLoc) return;
    if(isItem(nLoc)){
      applyItemDelta(nLoc, nInc);
    } else {
      if(typeof nInc.charged_vehicle !== "undefined"){
        nLoc.charged_vehicle = !!nInc.charged_vehicle;
      }
      const meta = extractVehicleMeta(nInc);
      nLoc.charged_vehicle_name = meta.vehicle ?? null;
      nLoc.charged_vehicle_operator = meta.operator ?? null;
      (nInc.children||[]).forEach(recInc);
      applyGroupDelta(nLoc, nInc);
    }
  });
  updateParentsBarOnly();
  recomputeStats();
}

/* ---------- Barre Parents ---------- */
function buildParentsBar(){
  const holder = document.getElementById("parents-bar");
  if(!holder) return;
  holder.innerHTML = "";
  const parents = (TREE||[]).filter(n => isGroup(n));
  parents.forEach(p => {
    const s = groupStatus(p);
    const pillClass = s==="OK" ? "pill-ok" : (s==="BAD" ? "pill-bad" : "pill-wait");
    const meta = extractVehicleMeta(p);
    const label = formatVehicleLabel(meta.vehicle, meta.operator);
    const pill = el("div", {class:"parent-pill "+pillClass, onclick:()=>scrollToParent(p.id)},
      statusDot(s==="OK", s==="BAD"),
      el("span", {class:"strong"}, p.name),
      p.charged_vehicle ? el("span", {class:"vehicle on"}, label) : null
    );
    holder.appendChild(pill);
  });
}
function updateParentsBarOnly(){
  buildParentsBar();
}
function scrollToParent(id){
  const target = document.getElementById("node-"+id);
  if(!target) return;
  target.scrollIntoView({behavior:"smooth", block:"start"});
  setTimeout(()=>{ window.scrollBy({top:-70, left:0, behavior:"instant"}); }, 300);
}

/* ---------- API ---------- */
async function refreshTree(){
  if(refreshInFlight){
    refreshQueued = true;
    return;
  }
  refreshInFlight = true;
  try{
    const r = await fetch(`/events/${EVENT_ID}/tree`, {credentials:"include"});
    if(!r.ok) return;
    const latest = await r.json();
    syncTreeIncoming(latest);
  }catch(_){}
  finally{
    refreshInFlight = false;
    if(refreshQueued){
      refreshQueued = false;
      await refreshTree();
    }
  }
}
function verify(nodeId, status){
  const payload = { node_id: nodeId, status, verifier_name: CURRENT_USER || "op" };
  fetch(`/events/${EVENT_ID}/verify`, {
    method:"POST", credentials:"include",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  })
  .then(res=>res.ok?refreshTree():res.text().then(t=>alert(t)))
  .catch(()=>{});
}

/* ---------- Boutons haut ---------- */
document.getElementById("btn-share").addEventListener("click", ()=>{
  fetch(`/events/${EVENT_ID}/share-link`, {method:"POST", credentials:"include"})
    .then(r=>r.json())
    .then(res=>{
      if(res && res.url){
        const absolute = location.origin + res.url;
        navigator.clipboard.writeText(absolute).catch(()=>{});
        alert("Lien secouristes copié : " + absolute);
      }else{
        alert("Impossible de générer le lien.");
      }
    })
    .catch(()=> alert("Erreur réseau"));
});

document.getElementById("btn-close").addEventListener("click", ()=>{
  fetch(`/events/${EVENT_ID}/status`, {
    method:"PATCH", credentials:"include",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify({status:"CLOSED"})
  }).then(()=>{
    IS_OPEN = false;
    document.getElementById("status-badge").textContent = "Statut : CLOSED";
    ITEM_EL.forEach(box=>{
      box.querySelectorAll("button").forEach(b=> b.disabled = true);
    });
  });
});

/* ---------- Init (polling + temps réel) ---------- */
(function init(){
  buildUIOnce();
  refreshTree();
  if(HAS_SOCKET_IO){
    setupSocket();
  }
  const interval = HAS_SOCKET_IO ? 15000 : 5000;
  setInterval(refreshTree, interval);
})();
</script>

{% endblock %}
