{% extends "base.html" %}
{% set title = "Événement" %}
{% block content %}
  <div class="grid cols-2">
    <div class="card">
      <div class="row space-between">
        <div>
          <div class="title">{{ event.name }}</div>
          <div class="subtitle">Date : {{ event.date or "—" }}</div>
        </div>
        <span class="badge" id="status-badge">Statut :
          {{ event.status if event.status is string else event.status.name }}
        </span>
      </div>

      <div class="row wrap" style="margin-top:10px; gap:8px;">
        <a class="btn" href="{{ url_for('pages.dashboard') }}">← Menu</a>
        <a class="btn ghost" href="{{ url_for('pages.logout') }}">Déconnexion</a>
        <button class="btn primary" id="btn-share">Générer un lien secouristes</button>
        <button class="btn" id="btn-close">Clôturer l'événement</button>
      </div>
    </div>

    <div class="card">
      <div class="title">Progression</div>
      <div class="progress" style="margin-top:8px;"><div id="progress-bar" style="width:0%"></div></div>
      <div class="subtitle" id="progress-text" style="margin-top:6px;">0 / 0 vérifiés</div>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <div class="row space-between">
      <div class="title">Matériel à vérifier</div>
      <div class="row" style="gap:8px;">
        <div class="subtitle">Nom & prénom :</div>
        <input id="global-name" placeholder="Nom & prénom" style="min-width:220px;">
      </div>
    </div>
    <div id="tree" class="tree" style="margin-top:10px;"></div>
  </div>

  <style>
    .ok-flag { font-weight:700; margin-left:6px; }
    .ok-flag.good { color:#12b886; }
    .chip { border-radius: 12px; padding: 2px 8px; font-size: 12px; }
    .chip.ok { background:#e6fcf5; color:#0ca678; border:1px solid #96f2d7; }
    .chip.ko { background:#fff5f5; color:#e03131; border:1px solid #ffc9c9; }
    .who { font-size:12px; color:#6b7280; margin-top:4px; }
    .node.item-ok > .header { border-left:4px solid #12b886; padding-left:8px; }
  </style>

  <script>
    const EVENT_ID = {{ event.id }};
    let TREE = {{ (tree or [])|tojson }};
    let okCount = 0, totalItems = 0;

    // ===== Socket (transports: polling d'abord pour proxy, puis websocket) =====
    let socket = null;
    let socketReady = false;
    try {
      socket = io({
        transports:["polling","websocket"],
        reconnection:true,
        reconnectionDelay:1000,
        reconnectionDelayMax:5000,
        timeout: 2000
      });
      socket.on("connect", () => {
        socketReady = true;
        socket.emit("join_event", {event_id: EVENT_ID});
      });
      socket.on("disconnect", () => { socketReady = false; });
      socket.on("event_update", (payload) => {
        if(payload?.event_id !== EVENT_ID) return;
        if(payload?.type === "item_verified"){
          applyVerificationToUI(payload.node_id, payload.status, payload.by || payload.verifier_name || "");
        }
        if(payload?.type === "parent_charged"){
          const cb = document.getElementById(`charged-${payload.node_id}`);
          if(cb) cb.checked = !!payload.charged;
        }
        if(payload?.type === "event_closed"){
          document.getElementById("status-badge").textContent = "Statut : CLOSED";
        }
      });
    } catch (e) { console.warn("Socket.IO indisponible:", e); }

    // ===== Fallback léger: rafraîchit juste la progression si pas de socket =====
    setInterval(async () => {
      if (socketReady) return;
      try{
        const r = await fetch(`/events/${EVENT_ID}/stats`, {credentials:"include"});
        if(!r.ok) return;
        const js = await r.json();
        if(js && typeof js.verified_ok==="number" && typeof js.verified_total==="number"){
          okCount = js.verified_ok;
          totalItems = js.verified_total;
          updateProgress(okCount, totalItems);
        }
      }catch(_){}
    }, 5000);

    // ===== DOM utils =====
    function el(tag, attrs={}, ...children){
      const e = document.createElement(tag);
      for(const [k,v] of Object.entries(attrs||{})){
        if(k==="class") e.className = v;
        else if(k==="html") e.innerHTML = v;
        else if(k.startsWith("on") && typeof v==="function") e.addEventListener(k.slice(2), v);
        else e.setAttribute(k, v);
      }
      for(const c of children){ e.append(c?.nodeType ? c : document.createTextNode(String(c))); }
      return e;
    }

    // ===== Rendu =====
    function renderItemHeader(n){
      const nameEl = el("div", {class:"name"}, n.name);
      const chip = n.last_status
        ? el("span", {class: "chip " + (n.last_status==="OK" ? "ok" : "ko")}, n.last_status==="OK" ? "OK" : "Non conforme")
        : el("span", {class:"chip"}, "À vérifier");
      return el("div", {class:"header"}, nameEl, el("span", {class:"qty"}, `Qté: ${n.quantity ?? "—"}`), chip);
    }

    function renderItem(n){
      const header = renderItemHeader(n);
      const who = el("div", {class:"who", id:`who-${n.id}`},
        n.last_by ? `Validé par : ${n.last_by}` : ""
      );
      const actions = el("div", {class:"item"},
        el("div", {class:"subtitle"}, "Vérification"),
        el("div", {class:"row", style:"gap:6px;"},
          el("button", {class:"btn", onclick: () => verifyItem(n.id, "OK")}, "OK"),
          el("button", {class:"btn ghost", onclick: () => verifyItem(n.id, "NOT_OK")}, "Non conforme"),
        )
      );
      const node = el("div", {class:"node", id:`node-${n.id}`}, header, el("div",{class:"childs"}, who, actions));
      if(n.last_status === "OK"){ node.classList.add("item-ok"); }
      return node;
    }

    function renderGroupHeader(n){
      const nameEl = el("div", {class:"name"}, n.name);
      const tick = el("span", {class:"ok-flag" + (n.complete ? " good" : ""), id:`tick-${n.id}`}, n.complete ? "✓" : "");
      const chargedCtl = el("label", {class:"row", style:"gap:6px;"},
        el("input", {type:"checkbox", id:`charged-${n.id}`, onchange: e => setCharged(n.id, e.target.checked)}),
        el("span", {class:"subtitle"}, "Chargé dans le véhicule")
      );
      const right = el("div", {class:"row", style:"gap:8px; align-items:center;"},
        tick, chargedCtl
      );
      return el("div", {class:"header"}, nameEl, right);
    }

    function renderGroup(n){
      const header = renderGroupHeader(n);
      const childrenWrap = el("div", {class:"childs"});
      (n.children || []).forEach(ch => childrenWrap.appendChild(renderNode(ch)));
      return el("div", {class:"node", id:`node-${n.id}`}, header, childrenWrap);
    }

    function renderNode(n){ return n.type === "GROUP" ? renderGroup(n) : renderItem(n); }

    function flattenItems(nodes){
      const out = [];
      (function rec(list){
        list.forEach(n => { if(n.type==="ITEM") out.push(n); if(n.children?.length) rec(n.children); });
      })(nodes);
      return out;
    }

    function computeInitialProgress(){
      const items = flattenItems(TREE);
      totalItems = items.length;
      okCount   = items.filter(i => i.last_status === "OK").length;
      updateProgress(okCount, totalItems);
    }

    function updateProgress(ok, total){
      const pct = total ? Math.round((ok/total)*100) : 0;
      document.getElementById("progress-bar").style.width = pct + "%";
      document.getElementById("progress-text").textContent = `${ok} / ${total} vérifiés`;
    }

    function buildUI(){
      const treeEl = document.getElementById("tree");
      treeEl.innerHTML = "";
      if(!Array.isArray(TREE) || TREE.length===0){
        treeEl.append(el("div",{class:"item"}, el("div",{class:"subtitle"},"Aucun stock parent associé.")));
        updateProgress(0,0);
        return;
      }
      TREE.forEach(root => treeEl.appendChild(renderNode(root)));
      computeInitialProgress();
      // Fixe les ✓ initialement
      markAllParentTicks(TREE);
    }

    function markAllParentTicks(nodes){
      nodes.forEach(n => {
        if(n.type==="GROUP"){
          const tick = document.getElementById(`tick-${n.id}`);
          if(tick){ tick.textContent = n.complete ? "✓" : ""; tick.classList.toggle("good", !!n.complete); }
        }
        if(n.children?.length) markAllParentTicks(n.children);
      });
    }

    // ===== Actions =====
    function getName(){ return (document.getElementById("global-name").value || "").trim(); }

    async function verifyItem(nodeId, status){
      const name = getName();
      if(!name){ alert("Merci d'indiquer votre nom & prénom."); return; }
      const r = await fetch(`/events/${EVENT_ID}/verify`, {
        method:"POST", credentials:"include",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({node_id: nodeId, status, verifier_name: name})
      });
      if(!r.ok){ alert(await r.text().catch(()=> "Erreur")); return; }
      // Mise à jour locale immédiate
      applyVerificationToUI(nodeId, status, name);
    }

    async function setCharged(nodeId, checked){
      await fetch(`/events/${EVENT_ID}/parent-status`, {
        method:"POST", credentials:"include",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({node_id: nodeId, charged_vehicle: checked})
      });
    }

    // ===== Helpers de mise à jour =====
    function findNodeInTree(id){
      let found=null;
      (function rec(list){
        for(const n of list){
          if(n.id===id){ found=n; return; }
          if(n.children?.length){ rec(n.children); if(found) return; }
        }
      })(TREE);
      return found;
    }

    function parentMap(){
      const map = new Map();
      (function rec(list, parent){
        for(const n of list){
          map.set(n.id, parent || null);
          if(n.children?.length) rec(n.children, n);
        }
      })(TREE, null);
      return map;
    }
    const PARENT_MAP = parentMap();

    function aggregate(node){
      let ok=0, total=0;
      (function rec(n){
        if(n.type==="ITEM"){ total++; if(n.last_status==="OK") ok++; }
        (n.children||[]).forEach(rec);
      })(node);
      return {ok, total};
    }

    function updateParentTicksFrom(nodeId){
      let curId = nodeId;
      while(PARENT_MAP.has(curId)){
        const parent = PARENT_MAP.get(curId);
        if(!parent) break;
        const agg = aggregate(parent);
        parent.ok_count = agg.ok;
        parent.total_items = agg.total;
        parent.complete = (agg.total>0 && agg.ok===agg.total);
        const tick = document.getElementById(`tick-${parent.id}`);
        if(tick){ tick.textContent = parent.complete ? "✓" : ""; tick.classList.toggle("good", !!parent.complete); }
        curId = parent.id;
      }
    }

    function applyVerificationToUI(nodeId, status, by){
      const item = findNodeInTree(nodeId);
      if(!item) return;
      const prevOK = item.last_status === "OK";
      item.last_status = status;
      item.last_by = by || item.last_by || "";

      const node = document.getElementById(`node-${nodeId}`);
      if(node){
        const header = node.querySelector(".header");
        let chip = header?.querySelector(".chip");
        if(!chip){ chip = el("span",{class:"chip"},""); header.appendChild(chip); }
        chip.className = "chip " + (status==="OK" ? "ok" : "ko");
        chip.textContent = status==="OK" ? "OK" : "Non conforme";
        const who = node.querySelector(`#who-${nodeId}`);
        if(who){ who.textContent = by ? `Validé par : ${by}` : ""; }
        if(status==="OK") node.classList.add("item-ok"); else node.classList.remove("item-ok");
      }

      if(status==="OK" && !prevOK){ okCount = Math.min(totalItems, okCount+1); }
      if(status==="NOT_OK" && prevOK){ okCount = Math.max(0, okCount-1); }
      updateProgress(okCount, totalItems);
      updateParentTicksFrom(nodeId);
    }

    // ===== Boutons haut =====
    document.getElementById("btn-share").addEventListener("click", async () => {
      const r = await fetch(`/events/${EVENT_ID}/share-link`, {method:"POST", credentials:"include"});
      const res = await r.json().catch(()=> ({}));
      if(res?.url){
        const absolute = location.origin + res.url;
        try { await navigator.clipboard.writeText(absolute); } catch {}
        alert("Lien copié : " + absolute);
      } else {
        alert("Impossible de générer le lien.");
      }
    });

    document.getElementById("btn-close").addEventListener("click", async () => {
      const r = await fetch(`/events/${EVENT_ID}/status`, {
        method:"PATCH", credentials:"include",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({status:"CLOSED"})
      });
      if(r.ok){ location.reload(); } else { alert(await r.text()); }
    });

    // ===== Init =====
    (function init(){
      buildUI();
    })();
  </script>
{% endblock %}
