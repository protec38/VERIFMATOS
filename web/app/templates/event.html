{% extends "base.html" %}
{% set title = "Événement" %}
{% block content %}

<style>
  .state-ok{
    border-color: var(--success) !important;
    background:
      radial-gradient(600px 200px at top left, rgba(18,184,134,.15), transparent),
      #0f1e2f;
    box-shadow: 0 0 0 1px rgba(18,184,134,.35) inset, 0 0 18px rgba(18,184,134,.15);
  }
  .state-bad{
    border-color: var(--danger) !important;
    background:
      radial-gradient(600px 200px at top left, rgba(255,107,107,.12), transparent),
      #0f1a27;
    box-shadow: 0 0 0 1px rgba(255,107,107,.30) inset, 0 0 18px rgba(255,107,107,.12);
  }
  .state-wait{
    border-color: var(--border) !important;
    background:
      radial-gradient(600px 200px at top left, rgba(45,123,191,.08), transparent),
      var(--bg-2);
  }
  .chip{padding:4px 8px;border-radius:999px;font-weight:800;font-size:12px;border:1px solid var(--border);}
  .chip.ok{background:#0e2a24;color:#bff3e7;border-color:#1d6e5d}
  .chip.bad{background:#2a0e14;color:#ffd5dc;border-color:#75212f}
  .chip.wait{background:#101c2e;color:#b7c7dc;border-color:#24344f}

  .status-dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:8px;vertical-align:middle}
  .dot-ok{background:var(--success)} .dot-bad{background:var(--danger)} .dot-wait{background:#37527a}

  .parents-card .title{display:flex;align-items:center;gap:10px}
  .parents-bar{display:flex;gap:8px;overflow:auto;padding:8px 2px}
  .parent-pill{
    display:inline-flex;align-items:center;gap:8px;
    padding:8px 12px;border-radius:999px;border:1px solid var(--border);cursor:pointer;
    user-select:none;white-space:nowrap;transition:transform .08s ease, box-shadow .08s ease, border-color .08s ease;
    background:#0f1a2a;color:var(--text)
  }
  .parent-pill:hover{transform:translateY(-1px)}
  .pill-ok{border-color:#1d6e5d;background:#0e2a24;color:#bff3e7}
  .pill-bad{border-color:#75212f;background:#2a0e14;color:#ffd5dc}
  .pill-wait{border-color:#24344f;background:#101c2e;color:#b7c7dc}
  .focus-ring{outline:2px solid var(--pc-orange); outline-offset:2px; transition:outline-color .6s ease}
  .manage-card .parent-pill{cursor:default}
  .manage-card .parent-pill .btn{margin-left:6px}
  .btn.sm{padding:6px 8px;font-size:12px;border-radius:8px}
  .btn.sm:disabled{opacity:.6;cursor:not-allowed}
  #event-roots-status{margin-top:8px;font-size:13px;display:none;color:var(--muted)}
  #event-roots-status.success{color:#bff3e7}
  #event-roots-status.error{color:#ffd5dc}
  #event-roots-hint{margin-top:6px;font-size:13px;color:var(--muted)}

  .vehicle{font-size:12px; opacity:.9; padding:2px 6px; border-radius:6px; border:1px dashed var(--border); margin-left:8px}
  .vehicle.on{background:#0e2a24; color:#bff3e7; border-color:#1d6e5d}
  .vehicle.off{background:#101c2e; color:#b7c7dc; border-color:#24344f}
  .reassort-note{font-size:12px;padding:2px 6px;border-radius:6px;border:1px dashed rgba(245,199,111,.45);margin-left:8px;background:#33240f;color:#f5c76f;display:inline-flex;align-items:center;gap:6px}
  .reassort-note.empty{display:none}
  .parent-pill .reassort-chip{margin-left:8px;font-size:11px;padding:4px 8px;border-radius:999px;background:#2e1a07;color:#f5c76f;border:1px solid rgba(245,199,111,.35)}
  .modal-back{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:90}
  .modal-card{background:#0f1a2a;padding:20px;border-radius:12px;min-width:280px;max-width:420px;box-shadow:0 18px 45px rgba(0,0,0,.45)}
  .modal-card .title{margin-bottom:10px}
  .modal-card label{font-size:13px;color:var(--muted);margin-top:6px;display:block}
  .modal-card input,.modal-card textarea{width:100%;margin-top:6px}
  .modal-card .modal-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:16px}
  .modal-card textarea{min-height:90px;resize:vertical}
  .header.toggle{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-radius:10px;cursor:pointer}
  .header.toggle:hover{background:rgba(255,255,255,.04)}
  .header .left{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .header .group-name{font-weight:800}
  .chev{width:18px;display:inline-flex;align-items:center;justify-content:center;opacity:.85}
  .childs{padding:10px 12px 6px 28px}
  .childs.collapsed{display:none}
</style>

<div class="grid cols-2">
  <div class="card">
    <div class="row space-between">
      <div>
        <div class="title">{{ event.name }}</div>
        <div class="muted">Date : {{ event.date or "—" }}</div>
      </div>
      <span class="badge" id="status-badge">Statut : {{ event_status }}</span>
    </div>
    <div class="row wrap" style="margin-top:10px;">
      <a class="btn" target="_blank" href="/reports/event/{{ event.id }}/pdf">Exporter PDF</a>
      <button class="btn primary" id="btn-share">Lien secouristes</button>
      <button class="btn" id="btn-close">{{ "Clôturer l'événement" if event_status == "OPEN" else "Réouvrir l'événement" }}</button>
    </div>
  </div>

  <div class="card">
    <div class="title">Progression</div>
    <div class="row wrap" style="margin-top:8px;gap:10px;">
      <span class="chip ok" id="stat-ok">OK : 0</span>
      <span class="chip bad" id="stat-bad">Non conformes : 0</span>
      <span class="chip wait" id="stat-wait">En attente : 0</span>
    </div>
    <div class="progress" style="margin-top:10px;"><div id="progress-bar" style="width:0%"></div></div>
    <div class="muted" id="progress-text" style="margin-top:6px;">0 / 0 vérifiés</div>
  </div>
</div>

<div class="card parents-card" style="margin-top:12px;">
  <div class="title">Parents à vérifier</div>
  <div id="parents-bar" class="parents-bar"></div>
</div>

{% if can_manage %}
<div class="card manage-card" id="event-roots-card" style="margin-top:12px;">
  <div class="title">Gestion des parents</div>
  <div class="muted" style="margin-top:4px;">Ajoute ou retire des parents racines pour cet événement.</div>
  <div id="event-roots-list" class="row wrap" style="margin-top:12px;gap:8px;"></div>
  <div class="row wrap" style="margin-top:12px;gap:8px;">
    <select id="event-root-add-select" style="min-width:220px">
      <option value="">Ajouter un parent…</option>
    </select>
    <button class="btn primary sm manage-action" id="btn-add-root">Ajouter</button>
  </div>
  <div id="event-roots-hint"></div>
  <div id="event-roots-status" class="muted"></div>
</div>
{% endif %}

<div class="card" style="margin-top:12px;">
  <div class="row space-between">
    <div class="title">Matériel à vérifier</div>
    <div class="muted">Vert = tout OK • Rouge = au moins un non conforme • Bleu = en attente</div>
  </div>
  <div id="tree" class="tree" style="margin-top:10px;"></div>
</div>

<script>
const EVENT_ID = {{ event.id }};
let TREE = {{ (tree or [])|tojson }};
const CURRENT_USER = "{{ (current_user.username if current_user is defined and current_user.is_authenticated else '')|e }}";
const SHOW_VERIFY = {{ 'true' if allow_verify else 'false' }};
let IS_OPEN = ("{{ event_status }}".toUpperCase() === "OPEN");

const ALLOW_CHARGE = {{ 'true' if can_manage else 'false' }};

/* ========= State ========= */
const NODE_MAP = new Map();
const GROUP_EL = new Map();
const ITEM_EL  = new Map();
const ITEM_STATUS_TXT = new Map();
const ITEM_QTY_TXT = new Map();
const VEH_LABEL = new Map();
const CHARGE_BUTTON = new Map();
const REASSORT_LABEL = new Map();
const REASSORT_BUTTON = new Map();
const COLLAPSED = new Map();
const CAN_MANAGE = {{ 'true' if can_manage else 'false' }};
const EVENT_ROOTS = new Map();
const ROOT_CHOICES_MAP = new Map();
let ROOTS_STATUS_TIMER = null;
let ROOTS_SAVING = false;
let FULL_RELOAD_IN_PROGRESS = false;
let CHARGE_TARGET = null;
let REASSORT_TARGET = null;

/* ---------- Utils ---------- */
function indexTree(nodes){
  (nodes||[]).forEach(function rec(n){
    NODE_MAP.set(n.id, n);
    (n.children||[]).forEach(rec);
  });
}
function el(tag, attrs={}, ...children){
  const e = document.createElement(tag);
  for(const [k,v] of Object.entries(attrs||{})){
    if(k==="class") e.className = v;
    else if(k==="html") e.innerHTML = v;
    else if(k.startsWith("on") && typeof v==="function") e.addEventListener(k.slice(2), v);
    else e.setAttribute(k, v);
  }
  for(const c of children){ if(c!=null) e.append(c.nodeType?c:document.createTextNode(c)); }
  return e;
}
const isUnique = n => !!(n && n.unique_item);
const isUniqueParent = n => !!(n && n.unique_parent);
const targetNodeId = n => (n && (n.target_node_id || n.id));
const domSafeId = id => String(id).replace(/[^a-zA-Z0-9_-]/g, "-");
function formatChargeInfo(vehicle, operator){
  const veh = (vehicle && vehicle.trim()) ? vehicle.trim() : "—";
  if(operator && operator.trim()){
    return `${veh} (par ${operator.trim()})`;
  }
  return veh;
}
const isItem = n => {
  if(!n) return false;
  if(isUniqueParent(n)) return false;
  const type = (n.type||"").toUpperCase();
  return type === "ITEM" || (!!n.unique_item && !isUniqueParent(n));
};
const isGroup = n => !isItem(n);
function normStatus(s){
  s = (s||"").toUpperCase();
  if(s==="OK") return "OK";
  if(s==="NOT_OK" || s==="NOK" || s==="KO" || s==="NOT-OK" || s==="NOTOK") return "NOT_OK";
  return "PENDING";
}

/* ---------- Statuts ---------- */
function groupAllOk(n){
  const items = flattenItems([n]);
  return items.length > 0 && items.every(i => normStatus(i.last_status) === "OK");
}
function groupHasBad(n){
  return flattenItems([n]).some(i => normStatus(i.last_status) === "NOT_OK");
}
function canChargeGroup(n){
  if(!ALLOW_CHARGE) return false;
  if(!IS_OPEN) return false;
  return groupAllOk(n);
}
function groupStatus(n){
  if(groupAllOk(n)) return "OK";
  if(groupHasBad(n)) return "BAD";
  return "WAIT";
}
function flattenItems(nodes){
  const out=[]; (nodes||[]).forEach(function rec(n){
    if(isItem(n) || isUniqueParent(n)) out.push(n);
    (n.children||[]).forEach(rec);
  });
  return out;
}

/* ---------- Gestion parents événement ---------- */
function setRootsStatus(message, type="info", autoHideMs){
  if(!CAN_MANAGE) return;
  const el = document.getElementById("event-roots-status");
  if(!el) return;
  if(ROOTS_STATUS_TIMER){
    clearTimeout(ROOTS_STATUS_TIMER);
    ROOTS_STATUS_TIMER = null;
  }
  el.classList.remove("success", "error");
  if(!message){
    el.textContent = "";
    el.style.display = "none";
    return;
  }
  if(type === "success") el.classList.add("success");
  else if(type === "error") el.classList.add("error");
  el.textContent = message;
  el.style.display = "block";
  if(autoHideMs){
    ROOTS_STATUS_TIMER = setTimeout(() => {
      const target = document.getElementById("event-roots-status");
      if(target){
        target.textContent = "";
        target.style.display = "none";
        target.classList.remove("success", "error");
      }
      ROOTS_STATUS_TIMER = null;
    }, autoHideMs);
  }
}

function setRootsControlsDisabled(flag){
  if(!CAN_MANAGE) return;
  document.querySelectorAll('#event-roots-card .manage-action').forEach(btn => {
    btn.disabled = flag;
  });
  const select = document.getElementById("event-root-add-select");
  if(select){
    if(flag){
      select.disabled = true;
    }else{
      select.disabled = false;
      updateAddSelect();
    }
  }
}

function updateAddSelect(){
  if(!CAN_MANAGE) return;
  const select = document.getElementById("event-root-add-select");
  const hint = document.getElementById("event-roots-hint");
  const addBtn = document.getElementById("btn-add-root");
  if(!select) return;

  const available = [];
  ROOT_CHOICES_MAP.forEach(info => {
    if(!EVENT_ROOTS.has(info.id)){
      available.push(info);
    }
  });
  available.sort((a,b)=> (a.name||"").localeCompare(b.name||"", 'fr', {sensitivity:'base'}));

  const current = select.value;
  select.innerHTML = '<option value="">Ajouter un parent…</option>';
  available.forEach(info => {
    const opt = document.createElement('option');
    opt.value = String(info.id);
    opt.textContent = info.name || `Parent ${info.id}`;
    select.appendChild(opt);
  });
  if(current && available.some(info => String(info.id) === current)){
    select.value = current;
  }
  const disabled = (available.length === 0) || ROOTS_SAVING;
  select.disabled = disabled;
  if(addBtn){
    addBtn.disabled = disabled || ROOTS_SAVING;
  }
  if(hint){
    hint.textContent = available.length === 0
      ? "Tous les parents racines sont déjà associés à l'événement."
      : "";
  }
}

function renderManageRoots(){
  if(!CAN_MANAGE) return;
  const holder = document.getElementById("event-roots-list");
  if(!holder) return;
  holder.innerHTML = "";

  if(EVENT_ROOTS.size === 0){
    holder.appendChild(el("div", {class:"muted"}, "Aucun parent sélectionné pour cet événement."));
  } else {
    EVENT_ROOTS.forEach(spec => {
      const node = NODE_MAP.get(spec.id);
      const status = node ? groupStatus(node) : "WAIT";
      const pillClass = status === "OK" ? "pill-ok" : (status === "BAD" ? "pill-bad" : "pill-wait");
      const pill = el("div", {class:`parent-pill ${pillClass}`},
        statusDot(status === "OK", status === "BAD"),
        el("span", {class:"strong"}, spec.name || `Parent ${spec.id}`)
      );
      if(spec.unique_item){
        const qtyVal = (spec.quantity != null)
          ? spec.quantity
          : (spec.unique_quantity != null ? spec.unique_quantity : 1);
        pill.append(
          el("button", {
            class:"btn ghost sm manage-action",
            title:"Modifier la quantité",
            onclick:()=>changeRootQuantity(spec.id)
          }, `Qté: ${qtyVal}`)
        );
      }
      pill.append(
        el("button", {
          class:"btn danger sm manage-action",
          onclick:()=>removeRootFromEvent(spec.id)
        }, "Retirer")
      );
      holder.appendChild(pill);
    });
  }
  updateAddSelect();
}

function syncCurrentRootsFromTree(){
  if(!CAN_MANAGE) return;
  EVENT_ROOTS.clear();
  (TREE||[]).forEach(root => {
    if(!root || !isGroup(root)) return;
    const uniqQty = root.unique_quantity != null && root.unique_quantity !== ''
      ? Number.parseInt(root.unique_quantity, 10)
      : null;
    let selected = null;
    if(root.selected_quantity != null && root.selected_quantity !== ''){
      const parsed = Number.parseInt(root.selected_quantity, 10);
      selected = Number.isNaN(parsed) ? selected : parsed;
    } else if(root.quantity != null && root.quantity !== ''){
      const parsed = Number.parseInt(root.quantity, 10);
      selected = Number.isNaN(parsed) ? selected : parsed;
    } else if(uniqQty != null){
      selected = uniqQty;
    }
    EVENT_ROOTS.set(root.id, {
      id: root.id,
      name: root.name,
      unique_item: !!root.unique_item,
      unique_quantity: Number.isNaN(uniqQty) ? null : uniqQty,
      quantity: Number.isNaN(selected) ? null : selected,
    });
  });
  renderManageRoots();
}

async function ensureRootChoicesLoaded(){
  if(!CAN_MANAGE) return;
  if(ROOT_CHOICES_MAP.size > 0){
    updateAddSelect();
    return;
  }
  try{
    const res = await fetch('/stock/roots', {credentials:'include'});
    if(!res.ok) return;
    const data = await res.json();
    if(!Array.isArray(data)) return;
    ROOT_CHOICES_MAP.clear();
    data.forEach(entry => {
      if(!entry) return;
      const id = Number.parseInt(entry.id, 10);
      if(!id) return;
      const max = entry.unique_quantity != null ? Number.parseInt(entry.unique_quantity, 10) : null;
      ROOT_CHOICES_MAP.set(id, {
        id,
        name: entry.name || `Parent ${id}`,
        unique_item: !!entry.unique_item,
        unique_quantity: Number.isNaN(max) ? null : max,
      });
    });
    updateAddSelect();
  }catch(_){ }
}

function promptQuantityForRoot(info, initialValue){
  const label = info && info.name ? info.name : "ce parent";
  const max = info && info.unique_quantity != null ? info.unique_quantity : null;
  let current = (initialValue != null && !Number.isNaN(initialValue))
    ? Number(initialValue)
    : (max != null ? max : 1);
  while(true){
    const input = prompt(`Quantité désirée pour ${label}${max != null ? ` (max ${max})` : ''}`, String(current));
    if(input === null) return null;
    const qty = Number.parseInt(input, 10);
    if(Number.isNaN(qty) || qty < 0){
      alert('Quantité invalide');
      continue;
    }
    if(max != null && qty > max){
      alert(`Quantité supérieure au maximum (${max}).`);
      current = max;
      continue;
    }
    return qty;
  }
}

function buildRootsPayload(){
  const payload = [];
  EVENT_ROOTS.forEach(spec => {
    const entry = {id: spec.id};
    if(spec.unique_item){
      let qty = spec.quantity;
      if(qty == null){
        qty = spec.unique_quantity != null ? spec.unique_quantity : 1;
      }
      entry.quantity = qty;
    } else if(spec.quantity != null){
      entry.quantity = spec.quantity;
    }
    payload.push(entry);
  });
  return payload;
}

async function persistRoots(){
  if(!CAN_MANAGE) return false;
  const payload = buildRootsPayload();
  if(payload.length === 0){
    alert("Sélectionne au moins un parent");
    return false;
  }
  ROOTS_SAVING = true;
  setRootsControlsDisabled(true);
  setRootsStatus("Enregistrement en cours…", "info");
  try{
    const res = await fetch(`/events/${EVENT_ID}/roots`, {
      method:"PUT",
      credentials:"include",
      headers:{"Content-Type":"application/json", "Accept":"application/json"},
      body: JSON.stringify({roots: payload})
    });
    const text = await res.text();
    if(!res.ok){
      setRootsStatus("", "info");
      alert(text || "Impossible d'enregistrer la sélection.");
      return false;
    }
    setRootsStatus("Modifications enregistrées.", "success", 3200);
    return true;
  }catch(_){
    setRootsStatus("", "info");
    alert("Erreur réseau");
    return false;
  }finally{
    ROOTS_SAVING = false;
    setRootsControlsDisabled(false);
  }
}

async function reloadTreeFull(){
  if(FULL_RELOAD_IN_PROGRESS) return;
  FULL_RELOAD_IN_PROGRESS = true;
  try{
    const res = await fetch(`/events/${EVENT_ID}/tree`, {credentials:"include"});
    if(!res.ok) return;
    const latest = await res.json();
    TREE = latest;
    buildUIOnce();
  }catch(_){
  }finally{
    FULL_RELOAD_IN_PROGRESS = false;
  }
}

async function addRootToEvent(rootId){
  if(!CAN_MANAGE || !rootId) return;
  if(EVENT_ROOTS.has(rootId)){
    alert("Ce parent est déjà associé à l'événement.");
    return;
  }
  if(!ROOT_CHOICES_MAP.has(rootId)){
    await ensureRootChoicesLoaded();
  }
  const info = ROOT_CHOICES_MAP.get(rootId);
  if(!info){
    alert("Parent introuvable.");
    return;
  }
  let quantity = null;
  if(info.unique_item){
    const chosen = promptQuantityForRoot(info, info.unique_quantity);
    if(chosen === null) return;
    quantity = chosen;
  }
  const backup = new Map(EVENT_ROOTS);
  EVENT_ROOTS.set(rootId, {
    id: rootId,
    name: info.name,
    unique_item: !!info.unique_item,
    unique_quantity: info.unique_quantity,
    quantity,
  });
  renderManageRoots();
  const ok = await persistRoots();
  if(!ok){
    EVENT_ROOTS.clear();
    backup.forEach((value, key) => EVENT_ROOTS.set(key, value));
    renderManageRoots();
    return;
  }
  await reloadTreeFull();
}

async function removeRootFromEvent(rootId){
  if(!CAN_MANAGE || !EVENT_ROOTS.has(rootId)) return;
  const spec = EVENT_ROOTS.get(rootId);
  const label = spec && spec.name ? spec.name : "ce parent";
  if(!confirm(`Retirer ${label} de l'événement ?`)) return;
  const backup = new Map(EVENT_ROOTS);
  EVENT_ROOTS.delete(rootId);
  renderManageRoots();
  const ok = await persistRoots();
  if(!ok){
    EVENT_ROOTS.clear();
    backup.forEach((value, key) => EVENT_ROOTS.set(key, value));
    renderManageRoots();
    return;
  }
  await reloadTreeFull();
}

async function changeRootQuantity(rootId){
  if(!CAN_MANAGE) return;
  const spec = EVENT_ROOTS.get(rootId);
  if(!spec || !spec.unique_item) return;
  const info = ROOT_CHOICES_MAP.get(rootId) || {name: spec.name, unique_quantity: spec.unique_quantity};
  const current = spec.quantity != null ? spec.quantity : (spec.unique_quantity != null ? spec.unique_quantity : 1);
  const chosen = promptQuantityForRoot(info, current);
  if(chosen === null || chosen === spec.quantity) return;
  const previous = spec.quantity;
  spec.quantity = chosen;
  renderManageRoots();
  const ok = await persistRoots();
  if(!ok){
    spec.quantity = previous;
    renderManageRoots();
    return;
  }
  await reloadTreeFull();
}

/* ---------- Stats ---------- */
function recomputeStats(){
  const items = flattenItems(TREE);
  const total = items.length;
  const ok = items.filter(i=>normStatus(i.last_status)==="OK").length;
  const bad = items.filter(i=>normStatus(i.last_status)==="NOT_OK").length;
  const wait = total - ok - bad;

  document.getElementById("stat-ok").textContent = `OK : ${ok}`;
  document.getElementById("stat-bad").textContent = `Non conformes : ${bad}`;
  document.getElementById("stat-wait").textContent = `En attente : ${wait}`;
  const pct = total? Math.round(ok/total*100) : 0;
  document.getElementById("progress-bar").style.width = pct+"%";
  document.getElementById("progress-text").textContent = `${ok} / ${total} vérifiés`;
}

/* ---------- Rendu ---------- */
function itemStateClass(n){
  const s = normStatus(n.last_status);
  if(s==="OK") return "state-ok";
  if(s==="NOT_OK") return "state-bad";
  return "state-wait";
}
function groupStateClass(n){
  const s = groupStatus(n);
  if(s==="OK") return "state-ok";
  if(s==="BAD") return "state-bad";
  return "state-wait";
}
function statusDot(isOk, isBad){
  return el("span", {class:"status-dot "+(isOk?"dot-ok":(isBad?"dot-bad":"dot-wait"))});
}

function renderItem(n){
  const s = normStatus(n.last_status);
  const statusLbl = s==="OK" ? "✅ OK" : (s==="NOT_OK" ? "❌ Non conforme" : "⏳ En attente");
  const by = n.last_by ? ` (${n.last_by})` : "";
  const actionsEnabled = IS_OPEN && SHOW_VERIFY;
  const targetId = targetNodeId(n);
  const safeId = domSafeId(n.id);
  const qtyValue = (n.selected_quantity != null)
    ? n.selected_quantity
    : (n.quantity != null ? n.quantity : (n.unique_quantity != null ? n.unique_quantity : 1));

  const qtySpan = el("span", {class:"qty", id:`qty-${safeId}`}, `Qté: ${qtyValue}`);
  ITEM_QTY_TXT.set(n.id, qtySpan);

  const statusDiv = el("div", {class:"muted", id:`status-${safeId}`}, `Dernier statut: ${statusLbl}${by}`);
  ITEM_STATUS_TXT.set(n.id, statusDiv);

  const right = SHOW_VERIFY ? el("div", {class:"row"},
    el("button", {class:"btn success", disabled:!actionsEnabled, onclick:()=>verify(targetId,"OK")}, "OK"),
    el("button", {class:"btn ghost", disabled:!actionsEnabled, onclick:()=>verify(targetId,"NOT_OK")}, "Non conforme"),
  ) : null;

  const wrap = el("div", {class:"item "+itemStateClass(n), id:`item-${safeId}`},
    el("div", null,
      el("div", {class:"name"}, statusDot(s==="OK", s==="NOT_OK"), " ", n.name, " ", qtySpan),
      statusDiv
    ),
    right
  );
  ITEM_EL.set(n.id, wrap);
  return wrap;
}

function renderUniqueParentRow(n){
  const s = normStatus(n.last_status);
  const statusLbl = s==="OK" ? "✅ OK" : (s==="NOT_OK" ? "❌ Non conforme" : "⏳ En attente");
  const by = n.last_by ? ` (${n.last_by})` : "";
  const actionsEnabled = IS_OPEN && SHOW_VERIFY;
  const targetId = targetNodeId(n);
  const safeId = domSafeId(n.id);
  const qtyValue = (n.selected_quantity != null) ? n.selected_quantity : (n.quantity != null ? n.quantity : (n.unique_quantity != null ? n.unique_quantity : 1));

  const qtySpan = el("span", {class:"qty", id:`qty-${safeId}`}, `Qté: ${qtyValue}`);
  ITEM_QTY_TXT.set(n.id, qtySpan);

  const statusDiv = el("div", {class:"muted", id:`status-${safeId}`}, `Dernier statut: ${statusLbl}${by}`);
  ITEM_STATUS_TXT.set(n.id, statusDiv);

  const right = SHOW_VERIFY ? el("div", {class:"row"},
    el("button", {class:"btn success", disabled:!actionsEnabled, onclick:()=>verify(targetId,"OK")}, "OK"),
    el("button", {class:"btn ghost", disabled:!actionsEnabled, onclick:()=>verify(targetId,"NOT_OK")}, "Non conforme"),
  ) : null;

  const wrap = el("div", {class:`item unique-parent ${itemStateClass(n)}`, id:`item-${safeId}`},
    el("div", {class:"unique-info"},
      el("div", {class:"name"}, statusDot(s==="OK", s==="NOT_OK"), " Qté: ", qtySpan),
      statusDiv
    ),
    right
  );
  ITEM_EL.set(n.id, wrap);
  return wrap;
}

function renderGroup(n){
  const isRoot = !!n.is_event_root;
  const veh = isRoot
    ? el("span", {class:"vehicle "+(n.charged_vehicle?'on':'off')},
        n.charged_vehicle ? `Chargé : ${formatChargeInfo(n.charged_vehicle_name, n.charged_operator_name)}` : "Non chargé")
    : null;
  if(isRoot) VEH_LABEL.set(n.id, veh);

  let reassortBadge = null;
  if(isRoot){
    reassortBadge = el("span", {
      class:`reassort-note${n.reassort_note?"":" empty"}`,
      id:`reassort-${n.id}`,
    }, n.reassort_note ? `Réassort : ${n.reassort_note}` : "");
    REASSORT_LABEL.set(n.id, reassortBadge);
  }

  if(!COLLAPSED.has(n.id)) COLLAPSED.set(n.id, true);
  const collapsed = !!COLLAPSED.get(n.id);
  const gStatus = groupStatus(n);
  const chev = el("span", {class:"chev", id:`chev-${n.id}`}, collapsed ? "▸" : "▾");
  const headerLeft = el("div", {class:"left"},
    chev,
    statusDot(gStatus==="OK", gStatus==="BAD"),
    el("span", {class:"group-name"}, n.name),
    isRoot ? veh : null,
    isRoot ? reassortBadge : null,
  );

  let btnCharge = null;
  let btnReassort = null;
  if(isRoot && ALLOW_CHARGE){
    btnCharge = el("button", {
      class:"btn xs primary",
      onclick:(e)=>{ e.stopPropagation(); openChargeModal(n.id); }
    }, "Charger");
    CHARGE_BUTTON.set(n.id, btnCharge);

    btnReassort = el("button", {
      class:"btn xs",
      onclick:(e)=>{ e.stopPropagation(); openReassortModal(n.id); }
    }, "Réassort");
    if(!n.charged_vehicle){
      btnReassort.style.display = "none";
    }
    REASSORT_BUTTON.set(n.id, btnReassort);
  }

  const header = el("div", {class:"header toggle"}, headerLeft, el("div", {class:"actions"}, btnCharge, btnReassort));
  header.addEventListener("click", ()=>toggleCollapse(n.id));

  const bodyChildren = [];
  if(isUnique(n)){
    bodyChildren.push(renderUniqueParentRow(n));
  }
  (n.children||[]).forEach(child => {
    bodyChildren.push(renderNode(child));
  });
  const children = el("div", {class:`childs ${collapsed?"collapsed":""}`, id:`childs-${n.id}`}, ...bodyChildren);
  const box = el("div", {class:`node ${groupStateClass(n)}`, id:`node-${n.id}`}, header, children);
  GROUP_EL.set(n.id, box);
  if(isRoot){
    updateChargeButtonState(n.id);
    updateReassortUI(n.id);
  }
  return box;
}
function renderNode(n){ return isGroup(n) ? renderGroup(n) : renderItem(n); }

function updateChargeButtonState(parentId){
  const btn = CHARGE_BUTTON.get(parentId);
  const node = NODE_MAP.get(parentId);
  if(!btn || !node){ return; }
  const enable = canChargeGroup(node);
  btn.disabled = !enable;
  if(!enable){
    btn.title = IS_OPEN ? "Tous les éléments doivent être OK" : "Événement clôturé";
  } else {
    btn.title = "";
  }
}

function updateReassortUI(parentId){
  const node = NODE_MAP.get(parentId);
  const badge = REASSORT_LABEL.get(parentId);
  if(badge){
    const note = node && node.reassort_note ? node.reassort_note : "";
    badge.textContent = note ? `Réassort : ${note}` : "";
    badge.classList.toggle("empty", !note);
  }
  const btn = REASSORT_BUTTON.get(parentId);
  if(btn){
    const visible = !!(node && node.charged_vehicle && ALLOW_CHARGE && IS_OPEN);
    btn.style.display = visible ? "" : "none";
  }
}

function updateActionButtons(){
  const enable = IS_OPEN && SHOW_VERIFY;
  ITEM_EL.forEach(box => {
    box.querySelectorAll("button").forEach(btn => { btn.disabled = !enable; });
  });
}
function updateStatusUI(){
  const badge = document.getElementById("status-badge");
  if(badge) badge.textContent = `Statut : ${IS_OPEN ? "OPEN" : "CLOSED"}`;
  const btn = document.getElementById("btn-close");
  if(btn) btn.textContent = IS_OPEN ? "Clôturer l'événement" : "Réouvrir l'événement";
  if(ALLOW_CHARGE){
    NODE_MAP.forEach(n => {
      if(n && n.is_event_root){
        updateChargeButtonState(n.id);
        updateReassortUI(n.id);
      }
    });
  }
}

function buildUIOnce(){
  const root = document.getElementById("tree");
  if(!root) return;
  root.innerHTML = "";
  NODE_MAP.clear();
  GROUP_EL.clear();
  ITEM_EL.clear();
  ITEM_STATUS_TXT.clear();
  ITEM_QTY_TXT.clear();
  VEH_LABEL.clear();
  CHARGE_BUTTON.clear();
  REASSORT_LABEL.clear();
  REASSORT_BUTTON.clear();
  indexTree(TREE);
  (TREE||[]).forEach(n => root.appendChild(renderNode(n)));
  buildParentsBar();
  recomputeStats();
  updateActionButtons();
  updateStatusUI();
  if(CAN_MANAGE){
    syncCurrentRootsFromTree();
  }
}

/* ---------- MAJ incrémentales ---------- */
function applyItemDelta(local, incoming){
  // normalise & applique les nouvelles valeurs
  local.last_status = normStatus(incoming.last_status || "PENDING");
  local.last_by = incoming.last_by || "";
  if(incoming.quantity != null) local.quantity = incoming.quantity;
  if(typeof incoming.selected_quantity !== "undefined") local.selected_quantity = incoming.selected_quantity;
  if(typeof incoming.unique_quantity !== "undefined") local.unique_quantity = incoming.unique_quantity;
  if(typeof incoming.target_node_id !== "undefined") local.target_node_id = incoming.target_node_id;
  if(typeof incoming.unique_from_parent !== "undefined") local.unique_from_parent = incoming.unique_from_parent;

  const box = ITEM_EL.get(local.id);
  const statusDiv = ITEM_STATUS_TXT.get(local.id);
  const qtySpan = ITEM_QTY_TXT.get(local.id);
  if(!box) return;

  // 1) Classe visuelle de l'item (fond/contour)
  box.classList.remove("state-ok","state-bad","state-wait");
  box.classList.add(itemStateClass(local));

  // 2) ⚡️ Met à jour la pastille (dot) de l'item SANS F5
  const dot = box.querySelector(".status-dot");
  const s = normStatus(local.last_status);
  if(dot){
    dot.classList.remove("dot-ok","dot-bad","dot-wait");
    dot.classList.add(s==="OK" ? "dot-ok" : (s==="NOT_OK" ? "dot-bad" : "dot-wait"));
  }

  // 3) Texte d'état & quantité
  const label = s==="OK" ? "✅ OK" : (s==="NOT_OK" ? "❌ Non conforme" : "⏳ En attente");
  if(statusDiv) statusDiv.textContent = `Dernier statut: ${label}${local.last_by ? " ("+local.last_by+")" : ""}`;
  if(qtySpan){
    const qtyVal = (local.selected_quantity != null)
      ? local.selected_quantity
      : (local.quantity != null ? local.quantity : (local.unique_quantity != null ? local.unique_quantity : 1));
    qtySpan.textContent = `Qté: ${qtyVal}`;
  }
}

function applyGroupDelta(local, incoming){
  if(local.is_event_root && (typeof incoming.charged_vehicle !== "undefined")){
    local.charged_vehicle = !!incoming.charged_vehicle;
    if(typeof incoming.charged_vehicle_name !== "undefined"){
      local.charged_vehicle_name = incoming.charged_vehicle_name || null;
    }
    if(typeof incoming.operator_name !== "undefined"){
      local.charged_operator_name = incoming.operator_name || null;
    } else if(typeof incoming.charged_operator_name !== "undefined"){
      local.charged_operator_name = incoming.charged_operator_name || null;
    }
  }
  if(local.is_event_root && (typeof incoming.reassort_note !== "undefined")){
    local.reassort_note = incoming.reassort_note || null;
  }
  if(local.is_event_root && !local.charged_vehicle){
    local.reassort_note = null;
  }
  if(local.is_event_root){
    if(!local.charged_vehicle){
      local.charged_vehicle_name = null;
      local.charged_operator_name = null;
    }
    const lab = VEH_LABEL.get(local.id);
    if(lab){
      lab.classList.toggle("on", !!local.charged_vehicle);
      lab.classList.toggle("off", !local.charged_vehicle);
      lab.textContent = local.charged_vehicle
        ? `Chargé : ${formatChargeInfo(local.charged_vehicle_name, local.charged_operator_name)}`
        : "Non chargé";
    }
    updateReassortUI(local.id);
  }
  const box = GROUP_EL.get(local.id);
  if(!box) return;

  // Couleurs de panneau
  box.classList.remove("state-ok","state-bad","state-wait");
  box.classList.add(groupStateClass(local));

  // Pastille (dot) d'en-tête du groupe
  const dot = box.querySelector(".status-dot");
  if(dot){
    dot.classList.remove("dot-ok","dot-bad","dot-wait");
    const gs = groupStatus(local);
    dot.classList.add(gs==="OK" ? "dot-ok" : (gs==="BAD" ? "dot-bad" : "dot-wait"));
  }
}

function syncTreeIncoming(incomingRoots){
  (incomingRoots||[]).forEach(function recInc(nInc){
    const nLoc = NODE_MAP.get(nInc.id);
    if(!nLoc) return;
    if(isUnique(nLoc)){
      applyItemDelta(nLoc, nInc);
      if(nLoc.is_event_root){
        nLoc.charged_vehicle = !!nInc.charged_vehicle;
        nLoc.charged_vehicle_name = (typeof nInc.charged_vehicle_name !== "undefined" ? nInc.charged_vehicle_name : nLoc.charged_vehicle_name) || null;
        if(typeof nInc.operator_name !== "undefined"){
          nLoc.charged_operator_name = nInc.operator_name || null;
        } else if(typeof nInc.charged_operator_name !== "undefined"){
          nLoc.charged_operator_name = nInc.charged_operator_name || null;
        }
        if(typeof nInc.reassort_note !== "undefined"){
          nLoc.reassort_note = nInc.reassort_note || null;
        }
      }
      applyGroupDelta(nLoc, nInc);
      (nInc.children||[]).forEach(recInc);
    } else if(isItem(nLoc)){
      applyItemDelta(nLoc, nInc);
    } else {
      if(nLoc.is_event_root){
        nLoc.charged_vehicle = !!nInc.charged_vehicle;
        nLoc.charged_vehicle_name = (typeof nInc.charged_vehicle_name !== "undefined" ? nInc.charged_vehicle_name : nLoc.charged_vehicle_name) || null;
        if(typeof nInc.operator_name !== "undefined"){
          nLoc.charged_operator_name = nInc.operator_name || null;
        } else if(typeof nInc.charged_operator_name !== "undefined"){
          nLoc.charged_operator_name = nInc.charged_operator_name || null;
        }
        if(typeof nInc.reassort_note !== "undefined"){
          nLoc.reassort_note = nInc.reassort_note || null;
        }
      }
      (nInc.children||[]).forEach(recInc);
      applyGroupDelta(nLoc, nInc);
    }
  });
  updateParentsBarOnly();
  recomputeStats();
  updateActionButtons();
  if(CAN_MANAGE){
    renderManageRoots();
  }
}

/* ---------- Barre Parents ---------- */
function buildParentsBar(){
  const holder = document.getElementById("parents-bar");
  if(!holder) return;
  holder.innerHTML = "";
  const parents = (TREE||[]).filter(n => isGroup(n));
  parents.forEach(p => {
    const s = groupStatus(p);
    const pillClass = s==="OK" ? "pill-ok" : (s==="BAD" ? "pill-bad" : "pill-wait");
    const reassortChip = p.reassort_note ? el("span", {class:"reassort-chip"}, `Réassort : ${p.reassort_note}`) : null;
    const pill = el("div", {class:"parent-pill "+pillClass, onclick:()=>scrollToParent(p.id)},
      statusDot(s==="OK", s==="BAD"),
      el("span", {class:"strong"}, p.name),
      p.charged_vehicle ? el("span", {class:"vehicle on"}, formatChargeInfo(p.charged_vehicle_name, p.charged_operator_name)) : null,
      reassortChip
    );
    holder.appendChild(pill);
  });
}
function updateParentsBarOnly(){
  buildParentsBar();
}
function setCollapseState(id, collapsed){
  const value = !!collapsed;
  COLLAPSED.set(id, value);
  const cont = document.getElementById("childs-"+id);
  if(cont) cont.classList.toggle("collapsed", value);
  const chev = document.getElementById("chev-"+id);
  if(chev) chev.textContent = value ? "▸" : "▾";
}
function toggleCollapse(id){
  const current = COLLAPSED.has(id) ? !!COLLAPSED.get(id) : false;
  setCollapseState(id, !current);
}
function scrollToParent(id){
  setCollapseState(id, false);
  const target = document.getElementById("node-"+id);
  if(!target) return;
  target.scrollIntoView({behavior:"smooth", block:"start"});
  setTimeout(()=>{ window.scrollBy({top:-70, left:0, behavior:"instant"}); }, 300);
}

/* ---------- API ---------- */
async function refreshTree(){
  if(FULL_RELOAD_IN_PROGRESS || ROOTS_SAVING) return;
  try{
    const r = await fetch(`/events/${EVENT_ID}/tree`, {credentials:"include"});
    if(!r.ok) return;
    const latest = await r.json();
    syncTreeIncoming(latest);
  }catch(_){}
}
function verify(nodeId, status){
  const payload = { node_id: nodeId, status, verifier_name: CURRENT_USER || "op" };
  fetch(`/events/${EVENT_ID}/verify`, {
    method:"POST", credentials:"include",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  })
  .then(res=>res.ok?refreshTree():res.text().then(t=>alert(t)))
  .catch(()=>{});
}

/* ---------- Charger / Réassort ---------- */
function closeChargeModal(){
  document.getElementById("charge-modal")?.remove();
  CHARGE_TARGET = null;
}

function openChargeModal(parentId){
  if(!ALLOW_CHARGE) return;
  const node = NODE_MAP.get(parentId);
  if(!node) return;
  if(!IS_OPEN){ alert("Événement clôturé."); return; }
  if(!canChargeGroup(node)){ alert("Impossible : tous les éléments doivent être OK."); return; }
  closeChargeModal();
  CHARGE_TARGET = parentId;
  const modal = el("div", {id:"charge-modal", class:"modal-back"},
    el("div", {class:"modal-card"},
      el("div", {class:"title"}, "Charger le parent"),
      el("label", {for:"veh-name"}, "Nom du véhicule"),
      el("input", {id:"veh-name", placeholder:"Ex : VSAV-2", value: node.charged_vehicle_name || ""}),
      el("div", {class:"muted", style:"margin-top:8px"}, `Opérateur : ${CURRENT_USER || "—"}`),
      el("div", {class:"modal-actions"},
        el("button", {class:"btn ghost", onclick:closeChargeModal}, "Annuler"),
        el("button", {class:"btn primary", onclick:confirmCharge}, "Confirmer")
      )
    )
  );
  document.body.appendChild(modal);
  setTimeout(()=>document.getElementById("veh-name")?.focus(), 10);
}

function confirmCharge(){
  const veh = (document.getElementById("veh-name")?.value || "").trim();
  if(!veh){ alert("Merci d’indiquer le nom du véhicule."); return; }
  const targetId = CHARGE_TARGET;
  const payload = {
    node_id: targetId,
    charged_vehicle: true,
    vehicle_name: veh,
    operator_name: CURRENT_USER || "",
  };
  fetch(`/events/${EVENT_ID}/parent-status`, {
    method:"POST",
    credentials:"include",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  })
    .then(async res => {
      if(!res.ok){ const txt = await res.text(); throw new Error(txt || "Impossible de charger le parent."); }
      return res.json().catch(()=>({}));
    })
    .then(()=>{
      const node = NODE_MAP.get(targetId);
      if(node){
        node.charged_vehicle = true;
        node.charged_vehicle_name = veh;
        node.charged_operator_name = CURRENT_USER || null;
      }
      closeChargeModal();
      updateChargeButtonState(targetId);
      updateReassortUI(targetId);
      refreshTree();
    })
    .catch(err => alert(err.message || "Erreur réseau"));
}

function closeReassortModal(){
  document.getElementById("reassort-modal")?.remove();
  REASSORT_TARGET = null;
}

function openReassortModal(parentId){
  if(!ALLOW_CHARGE) return;
  const node = NODE_MAP.get(parentId);
  if(!node) return;
  if(!IS_OPEN){ alert("Événement clôturé."); return; }
  if(!node.charged_vehicle){ alert("Parent non chargé."); return; }
  closeReassortModal();
  REASSORT_TARGET = parentId;
  const modal = el("div", {id:"reassort-modal", class:"modal-back"},
    el("div", {class:"modal-card"},
      el("div", {class:"title"}, `Réassort – ${node.name}`),
      el("label", {for:"reassort-note"}, "Commentaire de réassort"),
      el("textarea", {id:"reassort-note", placeholder:"Ex : Ajouter 2 lots supplémentaires"}, node.reassort_note || ""),
      el("div", {class:"muted", style:"margin-top:8px"}, "Laisser vide pour supprimer le texte."),
      el("div", {class:"modal-actions"},
        el("button", {class:"btn ghost", onclick:closeReassortModal}, "Annuler"),
        el("button", {class:"btn primary", onclick:confirmReassort}, "Enregistrer")
      )
    )
  );
  document.body.appendChild(modal);
  setTimeout(()=>document.getElementById("reassort-note")?.focus(), 10);
}

function confirmReassort(){
  const textarea = document.getElementById("reassort-note");
  const note = (textarea?.value || "").trim();
  const targetId = REASSORT_TARGET;
  fetch(`/events/${EVENT_ID}/parent-reassort`, {
    method:"POST",
    credentials:"include",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify({ node_id: targetId, note })
  })
    .then(async res => {
      if(!res.ok){ const txt = await res.text(); throw new Error(txt || "Impossible d’enregistrer le réassort."); }
      return res.json().catch(()=>({}));
    })
    .then(()=>{
      const node = NODE_MAP.get(targetId);
      if(node){
        node.reassort_note = note || null;
        updateReassortUI(targetId);
        buildParentsBar();
      }
      closeReassortModal();
      refreshTree();
    })
    .catch(err => alert(err.message || "Erreur réseau"));
}

/* ---------- Boutons haut ---------- */
document.getElementById("btn-share").addEventListener("click", ()=>{
  fetch(`/events/${EVENT_ID}/share-link`, {method:"POST", credentials:"include"})
    .then(r=>r.json())
    .then(res=>{
      if(res && res.url){
        const absolute = location.origin + res.url;
        navigator.clipboard.writeText(absolute).catch(()=>{});
        alert("Lien secouristes copié : " + absolute);
      }else{
        alert("Impossible de générer le lien.");
      }
    })
    .catch(()=> alert("Erreur réseau"));
});

document.getElementById("btn-close").addEventListener("click", ()=>{
  const nextStatus = IS_OPEN ? "CLOSED" : "OPEN";
  fetch(`/events/${EVENT_ID}/status`, {
    method:"PATCH", credentials:"include",
    headers:{"Content-Type":"application/json"},
    body: JSON.stringify({status: nextStatus})
  })
  .then(res => {
    if(!res.ok){
      return res.text().then(txt => { throw new Error(txt || "Impossible de mettre à jour le statut."); });
    }
    return res.json().catch(()=>null);
  })
  .then(()=>{
    IS_OPEN = (nextStatus === "OPEN");
    updateActionButtons();
    updateStatusUI();
    refreshTree();
  })
  .catch(err => {
    alert(err.message || "Erreur réseau");
  });
});

/* ---------- Init (polling, comme avant) ---------- */
(function init(){
  buildUIOnce();
  if(CAN_MANAGE){
    ensureRootChoicesLoaded();
    const addBtn = document.getElementById("btn-add-root");
    if(addBtn){
      addBtn.addEventListener("click", async () => {
        const select = document.getElementById("event-root-add-select");
        if(!select) return;
        const value = Number.parseInt(select.value, 10);
        if(!value){
          alert("Sélectionne un parent à ajouter.");
          return;
        }
        await addRootToEvent(value);
        select.value = "";
      });
    }
  }
  setInterval(refreshTree, 2000);
})();
</script>
{% endblock %}
