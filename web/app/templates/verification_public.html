{% extends "base.html" %}
{% set title = "Vérification périodique — Lien public" %}
{% block content %}
<meta name="viewport" content="width=device-width, initial-scale=1" />

<div class="public-wrap">
  <section class="card tree-card">
    <div class="title">Matériel à vérifier</div>
    <p class="tree-note">Clique sur <strong>OK</strong> pour marquer les éléments contrôlés. Ces validations sont sauvegardées localement sur ce navigateur et ne synchronisent pas les autres personnes.</p>
    <div class="chipbar">
      <span class="chip ok" id="public-stat-ok">OK : 0</span>
      <span class="chip wait" id="public-stat-wait">En attente : 0</span>
    </div>
    <div class="progress"><div id="public-progress-bar"></div></div>
    <div class="muted tree-hint" id="public-progress-text">0 / 0 vérifiés</div>
    <div id="public-tree" class="tree"></div>
  </section>

  <section class="card finish-card">
    <div class="title">Finaliser la vérification</div>
    <p class="muted finish-note">Parent contrôlé : <strong>{{ root.name }}</strong></p>

    {% if success %}
      <div class="alert success">✅ Merci {{ recorded_name or '' }} ! La vérification a été enregistrée.</div>
      <p class="muted finish-note">Tu peux fermer cette page ou recommencer une nouvelle vérification si besoin.</p>
    {% else %}
      <div class="finish-header">
        <div class="finish-meta">
          <span>Vérificateur : <strong id="captured-name">Non renseigné</strong></span>
          <button type="button" class="btn ghost" id="edit-name-btn">Modifier le nom</button>
        </div>
        <div class="muted finish-guard" id="finish-guard">Valide tous les éléments pour pouvoir finir la vérification.</div>
      </div>

      {% if error %}
        <div class="alert error">{{ error }}</div>
      {% endif %}

      <form method="post" id="verification-form" class="finish-form">
        <input type="hidden" name="first_name" id="final-first-name" value="{{ first_prefill or '' }}">
        <input type="hidden" name="last_name" id="final-last-name" value="{{ last_prefill or '' }}">
        <textarea name="comment" placeholder="Commentaire (optionnel)">{{ comment_prefill or '' }}</textarea>
        <div class="finish-actions">
          <button class="btn primary" type="submit" id="finish-verification-btn" disabled>Finir la vérification</button>
        </div>
      </form>
    {% endif %}
  </section>
</div>

{% if not success %}
<div class="name-modal-backdrop" id="name-modal">
  <div class="name-modal">
    <h2>Avant de commencer</h2>
    <p>Indique ton prénom et ton nom pour enregistrer cette vérification.</p>
    <form id="name-capture-form">
      <div class="identity-row">
        <input id="modal-first-name" placeholder="Prénom" autocomplete="given-name" value="{{ first_prefill or '' }}">
        <input id="modal-last-name" placeholder="Nom" autocomplete="family-name" value="{{ last_prefill or '' }}">
      </div>
      <div class="modal-actions">
        <button type="submit" class="btn primary">Continuer</button>
      </div>
      <div class="alert error hidden" id="name-modal-error">Merci de renseigner ton prénom et ton nom.</div>
    </form>
  </div>
</div>
{% endif %}

<script>
const RAW_TREE = {{ tree_data|tojson }};
const TREE_DATA = Array.isArray(RAW_TREE) ? RAW_TREE : [];
const PUBLIC_TOKEN = {{ token|tojson }};
const STORAGE_KEY = PUBLIC_TOKEN ? `periodic_public_${PUBLIC_TOKEN}` : 'periodic_public';
const STATE = new Map();
let LAST_TOTAL = 0;
let LAST_OK = 0;

const FINISH_BUTTON = document.getElementById('finish-verification-btn');
const FINISH_GUARD = document.getElementById('finish-guard');
const NAME_DISPLAY = document.getElementById('captured-name');
const FIRST_FIELD = document.getElementById('final-first-name');
const LAST_FIELD = document.getElementById('final-last-name');
const NAME_MODAL = document.getElementById('name-modal');
const NAME_FORM = document.getElementById('name-capture-form');
const MODAL_FIRST_INPUT = document.getElementById('modal-first-name');
const MODAL_LAST_INPUT = document.getElementById('modal-last-name');
const NAME_MODAL_ERROR = document.getElementById('name-modal-error');
const EDIT_NAME_BTN = document.getElementById('edit-name-btn');
const VERIFICATION_FORM = document.getElementById('verification-form');

function updateNameDisplay(){
  if(!NAME_DISPLAY) return;
  const first = (FIRST_FIELD && FIRST_FIELD.value ? FIRST_FIELD.value : '').trim();
  const last = (LAST_FIELD && LAST_FIELD.value ? LAST_FIELD.value : '').trim();
  const full = `${first} ${last}`.trim();
  NAME_DISPLAY.textContent = full || 'Non renseigné';
}

function updateFinishState(){
  const hasButton = !!FINISH_BUTTON;
  const hasGuard = !!FINISH_GUARD;
  if(!hasButton && !hasGuard && !NAME_DISPLAY) return;
  const hasNames = Boolean((FIRST_FIELD && FIRST_FIELD.value ? FIRST_FIELD.value.trim() : '') && (LAST_FIELD && LAST_FIELD.value ? LAST_FIELD.value.trim() : ''));
  const total = LAST_TOTAL;
  const ok = LAST_OK;
  const allOk = total === 0 || ok === total;
  if(FINISH_BUTTON){
    FINISH_BUTTON.disabled = !(allOk && hasNames);
  }
  if(FINISH_GUARD){
    if(!hasNames){
      FINISH_GUARD.textContent = 'Renseigne ton prénom et ton nom pour pouvoir finir la vérification.';
    }else if(!allOk){
      FINISH_GUARD.textContent = 'Valide tous les éléments pour pouvoir finir la vérification.';
    }else{
      FINISH_GUARD.textContent = 'Tous les éléments sont vérifiés.';
    }
  }
  updateNameDisplay();
}

function populateNameModalInputs(){
  if(MODAL_FIRST_INPUT && FIRST_FIELD){
    MODAL_FIRST_INPUT.value = FIRST_FIELD.value || '';
  }
  if(MODAL_LAST_INPUT && LAST_FIELD){
    MODAL_LAST_INPUT.value = LAST_FIELD.value || '';
  }
}

function openNameModal(){
  if(!NAME_MODAL) return;
  populateNameModalInputs();
  NAME_MODAL.classList.add('visible');
  requestAnimationFrame(() => {
    if(MODAL_FIRST_INPUT){
      MODAL_FIRST_INPUT.focus();
    }
  });
}

function closeNameModal(){
  if(!NAME_MODAL) return;
  NAME_MODAL.classList.remove('visible');
}

if(NAME_FORM){
  NAME_FORM.addEventListener('submit', (evt) => {
    evt.preventDefault();
    const first = (MODAL_FIRST_INPUT && MODAL_FIRST_INPUT.value ? MODAL_FIRST_INPUT.value.trim() : '');
    const last = (MODAL_LAST_INPUT && MODAL_LAST_INPUT.value ? MODAL_LAST_INPUT.value.trim() : '');
    if(!first || !last){
      if(NAME_MODAL_ERROR){
        NAME_MODAL_ERROR.classList.remove('hidden');
      }
      return;
    }
    if(NAME_MODAL_ERROR){
      NAME_MODAL_ERROR.classList.add('hidden');
    }
    if(FIRST_FIELD) FIRST_FIELD.value = first;
    if(LAST_FIELD) LAST_FIELD.value = last;
    updateFinishState();
    closeNameModal();
  });
}

if(EDIT_NAME_BTN){
  EDIT_NAME_BTN.addEventListener('click', () => {
    openNameModal();
  });
}

function restoreState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    const parsed = JSON.parse(raw);
    if(parsed && typeof parsed === 'object'){
      STATE.clear();
      Object.entries(parsed).forEach(([k,v]) => {
        STATE.set(Number(k), v);
      });
    }
  }catch(e){}
}

function persistState(){
  try{
    const payload = {};
    for(const [k,v] of STATE.entries()){
      payload[k] = v;
    }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }catch(e){}
}

function renderTree(tree){
  const wrap = document.getElementById('public-tree');
  if(!wrap) return;
  wrap.innerHTML = '';
  LAST_TOTAL = 0;
  LAST_OK = 0;
  (tree||[]).forEach(node => wrap.appendChild(renderNode(node)));
  updateProgress();
}

function renderNode(node){
  const status = STATE.get(node.id) || 'WAIT';
  if(!node.children || !node.children.length){
    LAST_TOTAL += 1;
    if(status === 'OK') LAST_OK += 1;
  }
  const card = document.createElement('div');
  card.className = `node ${status === 'OK' ? 'state-ok' : 'state-wait'}`;
  const header = document.createElement('div');
  header.className = 'header';
  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = node.name || '—';
  header.appendChild(name);
  if(node.unique_item){
    const badge = document.createElement('span');
    badge.className = 'chip';
    badge.textContent = 'Objet unique';
    header.appendChild(badge);
  }
  card.appendChild(header);

  if(node.children && node.children.length){
    const childWrap = document.createElement('div');
    childWrap.className = 'childs';
    node.children.forEach(child => childWrap.appendChild(renderNode(child)));
    card.appendChild(childWrap);
  }else{
    const actions = document.createElement('div');
    actions.className = 'item-actions';
    const okBtn = document.createElement('button');
    okBtn.type = 'button';
    okBtn.className = 'btn success xs';
    okBtn.textContent = 'OK';
    okBtn.addEventListener('click', () => setState(node.id, 'OK'));
    const waitBtn = document.createElement('button');
    waitBtn.type = 'button';
    waitBtn.className = 'btn ghost xs';
    waitBtn.textContent = 'Réinitialiser';
    waitBtn.addEventListener('click', () => setState(node.id, 'WAIT'));
    actions.appendChild(okBtn);
    actions.appendChild(waitBtn);
    card.appendChild(actions);
  }
  return card;
}

function setState(id, status){
  STATE.set(id, status);
  persistState();
  renderTree(TREE_DATA);
}

function updateProgress(){
  const bar = document.getElementById('public-progress-bar');
  const text = document.getElementById('public-progress-text');
  const pct = LAST_TOTAL === 0 ? 0 : Math.round((LAST_OK / LAST_TOTAL) * 100);
  if(bar){ bar.style.width = pct + '%'; }
  if(text){ text.textContent = `${LAST_OK} / ${LAST_TOTAL} vérifiés`; }
  updateFinishState();
}

restoreState();
renderTree(TREE_DATA);
updateFinishState();
</script>
{% endblock %}
