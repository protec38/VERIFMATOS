{% extends "base.html" %}
{% set title = "Vérification publique" %}
{% block content %}
<div class="public-page">
  <section class="card public-hero">
    <div>
      <p class="eyebrow">Lien public</p>
      <h1 class="public-hero__title">Vérifie tout le matériel sur une seule page</h1>
      <p class="public-hero__subtitle">Catalogue complet, menu compact et interface qui s’adapte à tous les écrans.</p>
      <div class="public-hero__tags">
        <span class="chip chip--ghost">Catalogue global</span>
        <span class="chip chip--ghost">Responsive</span>
        <span class="chip chip--ghost">Menu compact</span>
      </div>
    </div>
    <div class="public-hero__cta">
      <div class="cta-card">
        <div class="cta-card__title">Comment ça marche ?</div>
        <ol>
          <li>Choisis le sac ou parent à contrôler.</li>
          <li>Déploie son contenu puis coche les statuts.</li>
          <li>Ajoute tes remarques et valide : elles arrivent côté admin.</li>
        </ol>
      </div>
    </div>
  </section>

  <section class="card public-selector">
    <div>
      <div class="title">Choisir un sac / parent</div>
      <p class="tree-note">Ce lien public liste tous les objets disponibles. Sélectionne ce que tu veux contrôler puis lance la vérification.</p>
    </div>
    <div class="selector-grid">
      <label for="bag-select" class="input-label">Objet à vérifier
        <select id="bag-select"></select>
      </label>
      <div class="selector-actions">
        <button id="start-public-verification" class="btn primary">Déployer la vérification</button>
        <div class="muted selector-actions__hint">Tout tient sur une page compacte et adaptée mobile.</div>
      </div>
    </div>
  </section>

  <div id="public-panels" class="public-grid is-hidden">
    <section class="card public-card public-card--accent">
      <div class="public-card__header">
        <div>
          <div class="title">Progression</div>
          <p class="muted" id="public-selected-object">Objet sélectionné : —</p>
        </div>
      </div>
      <div class="chipbar">
        <span class="chip ok" id="public-stat-ok">OK : 0</span>
        <span class="chip danger" id="public-stat-bad">Non conformes : 0</span>
        <span class="chip wait" id="public-stat-wait">En attente : 0</span>
      </div>
      <div class="progress"><div id="public-progress-bar"></div></div>
      <div class="muted tree-hint" id="public-progress-text">0 / 0 vérifiés</div>
    </section>

    <section class="card public-card public-card--tree">
      <div class="public-card__header">
        <div class="title">Sous-éléments à vérifier</div>
        <p class="muted tree-hint">Coche chaque item : vert = OK • rouge = manquant / non conforme • bleu = en attente.</p>
      </div>
      <div id="public-tree" class="tree"></div>
    </section>

    <section class="card public-card">
      <div class="public-card__header">
        <div class="title">Résumé des anomalies</div>
        <p class="muted tree-hint">Les items en rouge sont listés ici avec quantités et commentaires.</p>
      </div>
      <div id="issues-list" class="issues-list muted">Aucune anomalie pour l’instant.</div>
    </section>

    <section class="card public-card finish-card">
      <div class="public-card__header">
        <div class="title">Finaliser</div>
        <p class="tree-note">Signe la vérification et laisse un message pour l’équipe.</p>
      </div>
      <div id="feedback"></div>
      <form id="verification-form" class="finish-form">
        <div class="identity-row">
          <input id="first-name" placeholder="Prénom" autocomplete="given-name" value="{{ first_prefill or '' }}" required>
          <input id="last-name" placeholder="Nom" autocomplete="family-name" value="{{ last_prefill or '' }}" required>
        </div>
        <label class="input-label">Notes générales
          <textarea id="global-comment" placeholder="Ajoute un commentaire global (optionnel)">{{ comment_prefill or '' }}</textarea>
        </label>
        <div class="finish-actions">
          <button class="btn primary" type="submit" id="finish-verification-btn">Enregistrer la vérification</button>
        </div>
      </form>
    </section>
  </div>
</div>

<script>
const RAW_TREE = {{ tree_data|tojson }};
const TREE_DATA = Array.isArray(RAW_TREE) ? RAW_TREE : [];
const PUBLIC_SUBMIT_URL = {{ public_submit_url|tojson }} || window.location.pathname;
const STATE = new Map();
let LAST_TOTAL = 0;
let LAST_OK = 0;
let LAST_BAD = 0;
let SELECTED_PARENT = null;
let VERIFICATION_STARTED = false;

function walkNodes(nodes, fn){
  (nodes||[]).forEach(n => {
    fn(n);
    walkNodes(n.children, fn);
  });
}

function findNodeById(nodes, id){
  for(const node of nodes || []){
    if(Number(node.id) === Number(id)) return node;
    const child = findNodeById(node.children, id);
    if(child) return child;
  }
  return null;
}

function findRootIdForSelection(id){
  for(const root of TREE_DATA){
    const found = findNodeById([root], id);
    if(found){
      return Number(root.id);
    }
  }
  return null;
}

function collectParents(){
  return TREE_DATA.map(root => ({ id: root.id, label: root.name || 'Objet' }));
}

function collectScopedItems(){
  const allowed = [];
  const target = SELECTED_PARENT ? findNodeById(TREE_DATA, SELECTED_PARENT) : null;
  const scope = target ? [target] : TREE_DATA;
  scope.forEach(node => walkNodes([node], child => { if(isItem(child)) allowed.push(Number(child.id)); }));
  return allowed;
}

function getScopedNodes(){
  const selected = SELECTED_PARENT ? findNodeById(TREE_DATA, SELECTED_PARENT) : null;
  return selected ? [selected] : TREE_DATA;
}

function isItem(node){
  if(!node) return false;
  if(node.unique_parent) return true;
  const type = (node.type || '').toUpperCase();
  return type === 'ITEM' || (!!node.unique_item && !(node.children||[]).length);
}

function getNodeStatus(node){
  if(!node) return 'TODO';
  if(isItem(node)){
    return (STATE.get(node.id)?.status || 'TODO').toUpperCase();
  }
  const children = node.children || [];
  if(!children.length) return 'TODO';
  let hasBad = false;
  let hasWait = false;
  let hasOk = false;
  children.forEach(child => {
    const status = getNodeStatus(child);
    if(status === 'NOT_OK') hasBad = true;
    else if(status === 'OK') hasOk = true;
    else hasWait = true;
  });
  if(hasBad) return 'NOT_OK';
  if(hasWait) return 'TODO';
  return hasOk ? 'OK' : 'TODO';
}

function getInitialStatus(node){
  const last = (node.last_status || '').toUpperCase();
  if(last === 'OK' || last === 'NOT_OK') return last;
  return 'TODO';
}

function ensureState(node){
  if(!isItem(node)) return;
  if(!STATE.has(node.id)){
    STATE.set(node.id, {
      status: getInitialStatus(node),
      missing_qty: node.missing_qty ?? null,
      comment: node.comment || ''
    });
  }
}

function renderBagOptions(){
  const select = document.getElementById('bag-select');
  if(!select) return;
  select.innerHTML = '';
  collectParents().forEach(opt => {
    const o = document.createElement('option');
    o.value = String(opt.id);
    o.textContent = opt.label;
    select.appendChild(o);
  });
  SELECTED_PARENT = select.options.length ? Number(select.options[0].value) : null;
  updateSelectionLabel();
  select.addEventListener('change', () => {
    SELECTED_PARENT = Number(select.value);
    updateSelectionLabel();
    if(VERIFICATION_STARTED){
      renderTree(TREE_DATA);
    }
  });
}

function updateSelectionLabel(){
  const target = document.getElementById('public-selected-object');
  const select = document.getElementById('bag-select');
  if(!target || !select) return;
  const text = select.options[select.selectedIndex]?.textContent || '—';
  target.textContent = `Objet sélectionné : ${text}`;
}

function setState(id, status){
  const current = STATE.get(id) || {};
  STATE.set(id, { ...current, status });
  renderTree(TREE_DATA);
}

function setMissing(id, value){
  const v = value === '' ? null : Math.max(0, Number(value) || 0);
  const current = STATE.get(id) || {};
  STATE.set(id, { ...current, missing_qty: v });
  updateSummary();
}

function setComment(id, text){
  const current = STATE.get(id) || {};
  STATE.set(id, { ...current, comment: text || '' });
  updateSummary();
}

function renderTree(nodes){
  const wrap = document.getElementById('public-tree');
  if(!wrap) return;
  if(!VERIFICATION_STARTED){
    wrap.innerHTML = '<div class="muted">Clique sur « Vérifier » pour afficher le contenu sélectionné.</div>';
    return;
  }
  wrap.innerHTML = '';
  LAST_TOTAL = 0;
  LAST_OK = 0;
  LAST_BAD = 0;
  const selected = SELECTED_PARENT ? findNodeById(nodes, SELECTED_PARENT) : null;
  const toRender = selected ? [selected] : (nodes || []);
  if(!toRender.length){
    wrap.innerHTML = '<div class="muted">Aucun contenu pour cet objet.</div>';
    updateProgress();
    updateSummary();
    return;
  }
  toRender.forEach(node => wrap.appendChild(renderNode(node)));
  updateProgress();
  updateSummary();
}

function renderNode(node){
  const statusInfo = STATE.get(node.id) || {};
  const status = getNodeStatus(node);
  if(isItem(node)){
    LAST_TOTAL += 1;
    if(status === 'OK') LAST_OK += 1;
    else if(status === 'NOT_OK') LAST_BAD += 1;
  }
  const card = document.createElement('div');
  card.className = `node ${status === 'OK' ? 'state-ok' : status === 'NOT_OK' ? 'state-bad' : 'state-wait'}`;
  const header = document.createElement('div');
  header.className = 'header' + (node.children && node.children.length ? ' toggle' : '');
  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = node.name || '—';
  header.appendChild(name);

  const badge = document.createElement('span');
  badge.className = `status-pill ${status === 'OK' ? 'is-ok' : status === 'NOT_OK' ? 'is-bad' : 'is-wait'}`;
  badge.textContent = status === 'OK' ? 'Validé' : status === 'NOT_OK' ? 'Anomalie' : 'À vérifier';
  header.appendChild(badge);

  const hasChildren = node.children && node.children.length;
  let childWrap = null;
  if(hasChildren){
    childWrap = document.createElement('div');
    childWrap.className = 'childs';
    const meta = document.createElement('div');
    meta.className = 'muted';
    meta.textContent = `${node.children.length} sous-élément(s)`;
    header.appendChild(meta);
    header.addEventListener('click', () => {
      if(childWrap){
        childWrap.classList.toggle('collapsed');
      }
    });
  } else {
    const actions = document.createElement('div');
    actions.className = 'item-actions';
    const okBtn = document.createElement('button');
    okBtn.type = 'button';
    okBtn.className = 'btn success xs';
    okBtn.textContent = 'OK';
    okBtn.addEventListener('click', () => setState(node.id, 'OK'));
    const badBtn = document.createElement('button');
    badBtn.type = 'button';
    badBtn.className = 'btn danger xs';
    badBtn.textContent = 'Manquant';
    badBtn.addEventListener('click', () => setState(node.id, 'NOT_OK'));
    const waitBtn = document.createElement('button');
    waitBtn.type = 'button';
    waitBtn.className = 'btn ghost xs';
    waitBtn.textContent = 'Attente';
    waitBtn.addEventListener('click', () => setState(node.id, 'TODO'));
    actions.appendChild(okBtn);
    actions.appendChild(badBtn);
    actions.appendChild(waitBtn);
    header.appendChild(actions);
  }

  card.appendChild(header);

  if(hasChildren && childWrap){
    node.children.forEach(child => childWrap.appendChild(renderNode(child)));
    card.appendChild(childWrap);
  }else{
    const detail = document.createElement('div');
    detail.className = 'item-detail';
    const qtyLabel = document.createElement('label');
    qtyLabel.textContent = 'Quantité manquante (optionnel)';
    const qtyInput = document.createElement('input');
    qtyInput.type = 'number';
    qtyInput.min = '0';
    qtyInput.value = statusInfo.missing_qty ?? '';
    qtyInput.addEventListener('input', () => setMissing(node.id, qtyInput.value));

    const commentLabel = document.createElement('label');
    commentLabel.textContent = 'Note (optionnel)';
    const commentInput = document.createElement('textarea');
    commentInput.value = statusInfo.comment || '';
    commentInput.placeholder = 'Précision sur ce qui manque ou est défectueux';
    commentInput.addEventListener('input', () => setComment(node.id, commentInput.value));

    detail.appendChild(qtyLabel);
    detail.appendChild(qtyInput);
    detail.appendChild(commentLabel);
    detail.appendChild(commentInput);
    if(status !== 'NOT_OK'){
      detail.classList.add('collapsed');
    }
    card.appendChild(detail);
  }
  return card;
}

function updateProgress(){
  const bar = document.getElementById('public-progress-bar');
  const text = document.getElementById('public-progress-text');
  const wait = Math.max(LAST_TOTAL - LAST_OK - LAST_BAD, 0);
  const pct = LAST_TOTAL === 0 ? 0 : Math.round((LAST_OK / LAST_TOTAL) * 100);
  if(bar){ bar.style.width = pct + '%'; }
  if(text){ text.textContent = `${LAST_OK} / ${LAST_TOTAL} vérifiés`; }
  const okChip = document.getElementById('public-stat-ok');
  const badChip = document.getElementById('public-stat-bad');
  const waitChip = document.getElementById('public-stat-wait');
  if(okChip) okChip.textContent = `OK : ${LAST_OK}`;
  if(badChip) badChip.textContent = `Non conformes : ${LAST_BAD}`;
  if(waitChip) waitChip.textContent = `En attente : ${wait}`;
}

function updateSummary(){
  const list = document.getElementById('issues-list');
  if(!list) return;
  list.innerHTML = '';
  const problems = [];
  getScopedNodes().forEach(root => walkNodes([root], n => {
    if(!isItem(n)) return;
    const s = (STATE.get(n.id)?.status || 'TODO').toUpperCase();
    if(s === 'NOT_OK'){
      problems.push({
        id: n.id,
        name: n.name || '—',
        missing_qty: STATE.get(n.id)?.missing_qty,
        comment: STATE.get(n.id)?.comment || ''
      });
    }
  }));
  if(!problems.length){
    list.classList.add('muted');
    list.textContent = 'Aucune anomalie pour l’instant.';
    return;
  }
  list.classList.remove('muted');
  problems.forEach(p => {
    const row = document.createElement('div');
    row.className = 'issue-row';
    const title = document.createElement('div');
    title.className = 'issue-title';
    title.textContent = p.name;
    row.appendChild(title);
    if(p.missing_qty !== null && p.missing_qty !== undefined && p.missing_qty !== ''){
      const qty = document.createElement('div');
      qty.className = 'issue-meta';
      qty.textContent = `Manquant: ${p.missing_qty}`;
      row.appendChild(qty);
    }
    if(p.comment){
      const comment = document.createElement('div');
      comment.className = 'issue-comment';
      comment.textContent = p.comment;
      row.appendChild(comment);
    }
    list.appendChild(row);
  });
}

function buildPayload(){
  const items = [];
  const allowedIds = new Set(collectScopedItems());
  STATE.forEach((state, id) => {
    const numId = Number(id);
    if(allowedIds.size && !allowedIds.has(numId)) return;
    items.push({
      node_id: numId,
      status: state.status || 'TODO',
      missing_qty: state.missing_qty,
      observed_qty: null,
      comment: state.comment || null,
    });
  });
  return items;
}

function submitForm(evt){
  evt.preventDefault();
  const first = (document.getElementById('first-name')?.value || '').trim();
  const last = (document.getElementById('last-name')?.value || '').trim();
  const comment = (document.getElementById('global-comment')?.value || '').trim();
  const feedback = document.getElementById('feedback');
  const btn = document.getElementById('finish-verification-btn');
  const rootId = findRootIdForSelection(SELECTED_PARENT);
  if(!rootId){
    if(feedback){
      feedback.innerHTML = '<div class="alert error">Choisis un objet à vérifier avant d’enregistrer.</div>';
    }
    return;
  }
  if(!first || !last){
    if(feedback){
      feedback.innerHTML = '<div class="alert error">Merci de renseigner ton prénom et ton nom.</div>';
    }
    return;
  }
  if(btn){ btn.disabled = true; }
  fetch(PUBLIC_SUBMIT_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      root_id: rootId,
      first_name: first,
      last_name: last,
      comment,
      items: buildPayload(),
    })
  }).then(async resp => {
    const data = await resp.json().catch(() => ({}));
    if(resp.ok){
      if(feedback){
        feedback.innerHTML = `<div class="alert success">✅ Vérification enregistrée pour ${first}. (${data.session?.missing_items || 0} anomalie(s))</div>`;
      }
    }else{
      const message = data.error || 'Impossible d’enregistrer la vérification.';
      if(feedback){
        feedback.innerHTML = `<div class="alert error">${message}</div>`;
      }
    }
  }).catch(() => {
    if(feedback){
      feedback.innerHTML = '<div class="alert error">Erreur réseau, merci de réessayer.</div>';
    }
  }).finally(() => {
    if(btn){ btn.disabled = false; }
  });
}

function init(){
  walkNodes(TREE_DATA, ensureState);
  renderBagOptions();
  const form = document.getElementById('verification-form');
  if(form){
    form.addEventListener('submit', submitForm);
  }
  const startBtn = document.getElementById('start-public-verification');
  if(startBtn){
    startBtn.addEventListener('click', () => {
      if(!SELECTED_PARENT){
        document.getElementById('public-tree').innerHTML = '<div class="muted">Aucun objet n’est disponible pour l’instant.</div>';
        return;
      }
      VERIFICATION_STARTED = true;
      document.getElementById('public-panels')?.classList.remove('is-hidden');
      renderTree(TREE_DATA);
      updateProgress();
      updateSummary();
    });
  }
  renderTree(TREE_DATA);
}

init();
</script>
{% endblock %}
